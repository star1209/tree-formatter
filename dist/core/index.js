"use strict";exports.buildEnhancedTree=function(e,t={},n){const o=t.idKey||"id",r=t.parentKey||"parentId",s=t.childrenKey||"children",a=t.rootParentId??0,i=t.enableGhostNodes||!1,d=!1!==t.validateNodes,l=t.maxDepth||1e3,c=t.detectCycles||!1,h=t.onCycleDetected||((e,t)=>{console.warn(`发现循环引用，路径: ${t.join(" -> ")}`)}),f=t.sortChildren,p=t.formatNode,u=t.isRootNode,y=performance.now(),g=process.memoryUsage?.()?.heapUsed||0,m={totalNodes:0,rootNodes:0,maxDepth:0,buildTime:0,memoryUsed:0,cyclesDetected:0,ghostNodesCreated:0};if(!Array.isArray(e)||0===e.length)return[];const I=new Map;for(const G of e){const C=G[o],M=G[r]??null;d&&null==C?console.warn(`节点缺少ID字段 "${o}"，将被忽略:`,G):C!==M?I.set(C,{original:G,formatted:null,parentId:M,children:[],depth:0}):c&&(h(G,[C]),m.cyclesDetected++)}if(m.totalNodes=I.size,c&&I.size>0){const U=new Set,v=new Set,S=[];function T(e){if(v.has(e)){const t=S.indexOf(e);if(-1!==t){const n=S.slice(t);h(I.get(e).original,n),m.cyclesDetected++}return}if(U.has(e))return;U.add(e),v.add(e),S.push(e);const t=I.get(e);if(t&&null!==t.parentId){const n=t.parentId;I.has(n)&&e!==n&&T(n)}v.delete(e),S.pop()}I.forEach((e,t)=>{U.has(t)||T(t)})}const K=new Map;for(const[E,F]of I){const{parentId:P}=F;if(E!==P&&null!=P){if(I.get(P))K.has(P)||K.set(P,[]),K.get(P).push(F);else if(i){const j=P,z={original:{[o]:j},formatted:null,parentId:null,children:[],depth:0,isGhost:!0};I.set(j,z),K.has(j)||K.set(j,[]),K.get(j).push(F),m.ghostNodesCreated++}}}const w=[],D=[],N=new Set,x=[];I.forEach((e,t)=>{const{parentId:n,isGhost:o}=e;let r=!1;r=u?u(e.original):null==n||n===a,r&&(x.push({nodeInfo:e,id:t}),m.rootNodes++)}),x.sort((e,t)=>e.id-t.id);for(let L=x.length-1;L>=0;L--){const{nodeInfo:O,id:R}=x[L];D.push({nodeInfo:O,parentFormatted:null,depth:1,path:[R]})}for(;D.length>0;){const{nodeInfo:k,parentFormatted:q,depth:B,path:H}=D.pop();if(m.maxDepth=Math.max(m.maxDepth,B),B>l){console.warn(`节点 "${H.join(" -> ")}" 深度超过限制: ${B}`);continue}const J=k.original[o];if(N.has(J))continue;N.add(J);let Q=null;q&&(Q={...q},Q[s]&&delete Q[s]);const V=K.get(J)||[],W={level:B,path:H,isLeaf:0===V.length,parent:Q,childCount:V.length};let X;if(X=n?n(k.original,W):p?p(k.original,W):{...k.original},k.isGhost&&(X.__isGhost=!0),k.parentId?X.__parentId=k.parentId:X.__parentId=null,X[s]=[],k.formatted=X,q||w.push(X),f&&V.length>0)try{V.sort((e,t)=>f(e.original,t.original))}catch(Y){console.warn("子节点排序失败:",Y)}for(let Z=V.length-1;Z>=0;Z--){const ee=V[Z],te=ee.original[o],ne=[...H,te],oe=B+1;D.push({nodeInfo:ee,parentFormatted:X,depth:oe,path:ne})}}const A=new Map;I.forEach((e,t)=>{e.formatted&&A.set(e.formatted,t)});const $=[...w];for(;$.length>0;){const re=$.pop(),se=A.get(re),ae=[],ie=K.get(se)||[];for(const de of ie)de.formatted&&(ae.push(de.formatted),$.push(de.formatted));re[s]=ae}const _=performance.now(),b=process.memoryUsage?.()?.heapUsed||0;return m.buildTime=_-y,m.memoryUsed=(b-g)/1048576,w.__stats=m,function e(t){for(const n of t)Array.isArray(n[s])&&0===n[s].length?delete n[s]:e(n[s]||[])}(w),w},exports.buildMinimalTree=function(e,t={}){const n={idKey:"id",parentKey:"parentId",childrenKey:"children",rootParentId:0,enableGhostNodes:!1,validateNodes:!0,maxDepth:1e3,enableCache:!1,...t};if(!Array.isArray(e)||0===e.length)return[];const o=new Map,r=[];for(const t of e){const e=t[n.idKey];n.validateNodes&&null==e?console.warn(`节点缺少ID字段 "${n.idKey}"，将被忽略:`,t):(o.has(e)&&console.warn(`发现重复ID "${e}"，后一个节点将覆盖前一个`),o.set(e,{...t,[n.childrenKey]:[]}))}const s=new Set;for(const t of e){const e=t[n.idKey],a=t[n.parentKey],i=o.get(e);if(!i)continue;if(s.has(e))continue;s.add(e);if(null==a||a===n.rootParentId)r.push(i);else{const t=o.get(a);if(t)t[n.childrenKey].push(i);else if(n.enableGhostNodes){const e={[n.idKey]:a,[n.childrenKey]:[i],__isGhost:!0};o.set(a,e),r.push(e)}else console.warn(`父节点 "${a}" 不存在，节点 "${e}" 将被作为根节点`),r.push(i)}}return function e(t){for(const o of t)Array.isArray(o[n.childrenKey])&&0===o[n.childrenKey].length?delete o[n.childrenKey]:e(o[n.childrenKey])}(r),r},exports.validateMinimalTree=function(e,t={}){const n=new Set,o=t.childrenKey||"children";function r(e,s){const a=e[t.idKey||"id"];if(n.has(a))return console.error(`发现循环引用，节点ID: ${a}`),!1;if(n.add(a),s>(t.maxDepth||1e3))return console.error(`树深度超过限制: ${s}`),!1;const i=e[o];if(Array.isArray(i))for(const e of i)if(!r(e,s+1))return!1;return n.delete(a),!0}try{for(const t of e)if(!r(t,1))return!1;return!0}catch(e){return console.error("树验证失败:",e),!1}};
//# sourceMappingURL=index.js.map
