{"version":3,"file":"index.js","sources":["../../src/core/enhanced.ts","../../src/core/minimal.ts"],"sourcesContent":["import { EnhancedTreeConfig, NodeContext, BuildStats } from './types';\n\n/**\n * 增强树形构建器\n * 支持循环引用检测、节点排序、格式化等高级功能\n */\nexport function buildEnhancedTree<T = any, R = T>(\n  list: T[],\n  options: EnhancedTreeConfig<T> = {},\n  formatCallback?: (node: T, context: NodeContext) => R\n): R[] {\n  // 提取配置，分别处理每个属性\n  const idKey = options.idKey || 'id';\n  const parentKey = options.parentKey || 'parentId';\n  const childrenKey = options.childrenKey || 'children';\n  const rootParentId = options.rootParentId ?? 0;\n  const enableGhostNodes = options.enableGhostNodes || false;\n  const validateNodes = options.validateNodes !== false; // 默认为true\n  const maxDepth = options.maxDepth || 1000;\n  const detectCycles = options.detectCycles || false;\n  const onCycleDetected = options.onCycleDetected || ((node: T, path: (string | number)[]) => {\n    console.warn(`发现循环引用，路径: ${path.join(' -> ')}`);\n  });\n  const sortChildren = options.sortChildren;\n  const formatNode = options.formatNode;\n  const isRootNode = options.isRootNode;\n\n  // 性能监控\n  const startTime = performance.now();\n  const startMemory = process.memoryUsage?.()?.heapUsed || 0;\n  const stats: BuildStats = {\n    totalNodes: 0,\n    rootNodes: 0,\n    maxDepth: 0,\n    buildTime: 0,\n    memoryUsed: 0,\n    cyclesDetected: 0,\n    ghostNodesCreated: 0\n  };\n\n  // 空列表检查\n  if (!Array.isArray(list) || list.length === 0) {\n    return [];\n  }\n\n  // 节点映射表\n  const nodeMap = new Map<string | number, {\n    original: T;\n    formatted: any;\n    parentId: string | number | null;\n    children: any[];\n    depth: number;\n    isGhost?: boolean;\n  }>();\n\n  // 第一步：收集所有节点\n  for (const item of list) {\n    const id = (item as any)[idKey];\n    const parentId = (item as any)[parentKey] ?? null;\n\n    // 验证节点\n    if (validateNodes && (id === undefined || id === null)) {\n      console.warn(`节点缺少ID字段 \"${idKey}\"，将被忽略:`, item);\n      continue;\n    }\n\n    // 检查自引用\n    if (id === parentId) {\n      if (detectCycles) {\n        onCycleDetected(item, [id]);\n        stats.cyclesDetected++;\n      }\n      continue;\n    }\n\n    // 存储原始节点信息\n    nodeMap.set(id, {\n      original: item,\n      formatted: null,\n      parentId,\n      children: [],\n      depth: 0\n    });\n  }\n\n  stats.totalNodes = nodeMap.size;\n\n  // 第二步：检测循环引用（如果需要）\n  if (detectCycles && nodeMap.size > 0) {\n    // 使用深度优先搜索检测循环引用\n    const visited = new Set<string | number>();\n    const recursionStack = new Set<string | number>();\n    const path: (string | number)[] = [];\n    \n    // 深度优先搜索函数\n    function dfs(id: string | number) {\n      // 如果节点正在递归栈中，说明找到了循环\n      if (recursionStack.has(id)) {\n        const cycleStartIndex = path.indexOf(id);\n        if (cycleStartIndex !== -1) {\n          const cyclePath = path.slice(cycleStartIndex);\n          onCycleDetected(nodeMap.get(id)!.original, cyclePath);\n          stats.cyclesDetected++;\n        }\n        return;\n      }\n      \n      // 如果节点已经访问过，跳过\n      if (visited.has(id)) {\n        return;\n      }\n      \n      // 标记节点为已访问和在递归栈中\n      visited.add(id);\n      recursionStack.add(id);\n      path.push(id);\n      \n      // 获取节点的父节点\n      const nodeInfo = nodeMap.get(id);\n      if (nodeInfo && nodeInfo.parentId !== null) {\n        const parentId = nodeInfo.parentId;\n        if (nodeMap.has(parentId) && id !== parentId) {\n          dfs(parentId);\n        }\n      }\n      \n      // 从递归栈和路径中移除节点\n      recursionStack.delete(id);\n      path.pop();\n    }\n    \n    // 遍历所有节点\n    nodeMap.forEach((nodeInfo, id) => {\n      if (!visited.has(id)) {\n        dfs(id);\n      }\n    });\n  }\n\n  // 第三步：建立父子关系映射\n  const childrenMap = new Map<string | number, any[]>();\n  for (const [id, nodeInfo] of nodeMap) {\n    const { parentId } = nodeInfo;\n    \n    // 跳过自引用节点\n    if (id === parentId) {\n      continue;\n    }\n    \n    // 非根节点，寻找父节点\n    if (parentId !== null && parentId !== undefined) {\n      const parentInfo = nodeMap.get(parentId);\n      if (parentInfo) {\n        // 父节点存在，建立关系映射\n        if (!childrenMap.has(parentId)) {\n          childrenMap.set(parentId, []);\n        }\n        childrenMap.get(parentId)!.push(nodeInfo);\n      } else if (enableGhostNodes) {\n        // 父节点不存在，创建幽灵节点\n        const ghostId = parentId;\n        const ghostInfo = {\n          original: { [idKey]: ghostId } as T,\n          formatted: null,\n          parentId: null,\n          children: [],\n          depth: 0,\n          isGhost: true\n        };\n        \n        nodeMap.set(ghostId, ghostInfo);\n        \n        // 建立幽灵节点与子节点的关系映射\n        if (!childrenMap.has(ghostId)) {\n          childrenMap.set(ghostId, []);\n        }\n        childrenMap.get(ghostId)!.push(nodeInfo);\n        \n        stats.ghostNodesCreated++;\n      }\n    }\n  }\n\n  // 第四步：深度优先遍历构建树结构并格式化节点\n  const roots: R[] = [];\n  const stack: Array<{\n    nodeInfo: any;\n    parentFormatted: any | null;\n    depth: number;\n    path: (string | number)[];\n  }> = [];\n  \n  // 收集所有根节点 - 确保每个节点只被处理一次\n  const processedNodeIds = new Set<string | number>();\n  \n  // 识别真正的根节点\n  const rootNodes: any[] = [];\n  \n  // 只将真正的根节点添加到栈中\n  // 根节点的定义：\n  // 1. 使用自定义根节点判断函数返回true的节点\n  // 2. 父节点为rootParentId的节点\n  // 3. 没有父节点的节点\n  nodeMap.forEach((nodeInfo, id) => {\n    const { parentId, isGhost } = nodeInfo;\n    \n    let isRoot = false;\n    if (isRootNode) {\n      // 使用自定义根节点判断函数\n      isRoot = isRootNode(nodeInfo.original);\n    } else {\n      // 只有当节点的父节点为rootParentId或不存在时，才是根节点\n      isRoot = (parentId === null || parentId === undefined || parentId === rootParentId);\n    }\n    \n    if (isRoot) {\n      rootNodes.push({ nodeInfo, id });\n      stats.rootNodes++;\n    }\n  });\n  \n  // 按照 ID 排序根节点\n  rootNodes.sort((a, b) => {\n    return (a.id as number) - (b.id as number);\n  });\n  \n  // 初始化栈，处理所有根节点\n  // 反转根节点顺序，确保弹出顺序正确\n  for (let i = rootNodes.length - 1; i >= 0; i--) {\n    const { nodeInfo, id } = rootNodes[i];\n    stack.push({\n      nodeInfo,\n      parentFormatted: null,\n      depth: 1,\n      path: [id]\n    });\n  }\n  \n  // 深度优先遍历\n  while (stack.length > 0) {\n    const { nodeInfo, parentFormatted, depth, path } = stack.pop()!;\n    \n    // 更新最大深度\n    stats.maxDepth = Math.max(stats.maxDepth, depth);\n    \n    // 检查深度限制\n    if (depth > maxDepth) {\n      console.warn(`节点 \"${path.join(' -> ')}\" 深度超过限制: ${depth}`);\n      continue;\n    }\n\n    // 获取节点ID\n    const nodeId = nodeInfo.original[idKey];\n    \n    // 如果节点已经处理过，跳过\n    if (processedNodeIds.has(nodeId)) {\n      continue;\n    }\n    \n    // 标记节点为已处理\n    processedNodeIds.add(nodeId);\n\n    // 计算节点上下文 - 确保父节点不包含子节点，避免循环引用\n    let safeParent: any = null;\n    if (parentFormatted) {\n      // 创建父节点的安全副本，移除子节点引用，避免循环引用\n      safeParent = { ...parentFormatted };\n      // 移除子节点引用，避免循环引用\n      if (safeParent[childrenKey]) {\n        delete safeParent[childrenKey];\n      }\n    }\n    \n    // 使用childrenMap获取子节点列表\n    const children = childrenMap.get(nodeId) || [];\n    \n    const context: NodeContext = {\n      level: depth,\n      path: path,\n      isLeaf: children.length === 0,\n      parent: safeParent,\n      childCount: children.length\n    };\n    \n    // 格式化节点 - 只格式化一次\n    let formattedNode: any;\n    if (formatCallback) {\n      formattedNode = formatCallback(nodeInfo.original, context);\n    } else if (formatNode) {\n      formattedNode = formatNode(nodeInfo.original, context);\n    } else {\n      formattedNode = { ...nodeInfo.original };\n    }\n    \n    // 设置幽灵节点标记\n    if (nodeInfo.isGhost) {\n      formattedNode.__isGhost = true;\n    }\n    \n    // 设置父ID引用\n    if (nodeInfo.parentId) {\n      formattedNode.__parentId = nodeInfo.parentId;\n    } else {\n      formattedNode.__parentId = null;\n    }\n    \n    // 初始化子节点数组\n    formattedNode[childrenKey] = [];\n    \n    // 更新nodeMap中的格式化节点\n    nodeInfo.formatted = formattedNode;\n    \n    // 如果是根节点，添加到结果列表\n    if (!parentFormatted) {\n      roots.push(formattedNode as R);\n    }\n    \n    // 子节点排序\n    if (sortChildren && children.length > 0) {\n      try {\n        children.sort((a: any, b: any) => \n          sortChildren(a.original, b.original)\n        );\n      } catch (error) {\n        console.warn('子节点排序失败:', error);\n      }\n    }\n    \n    // 处理子节点 - 逆序压入栈，保证顺序正确\n    for (let i = children.length - 1; i >= 0; i--) {\n      const childInfo = children[i];\n      const childId = childInfo.original[idKey];\n      const childPath = [...path, childId];\n      const childDepth = depth + 1;\n      \n      stack.push({\n        nodeInfo: childInfo,\n        parentFormatted: formattedNode,\n        depth: childDepth,\n        path: childPath\n      });\n    }\n  }\n  \n  // 第五步：二次遍历，构建完整的子节点关系\n  // 注意：这里不需要重新格式化节点，只需要构建子节点列表\n  \n  // 创建一个映射，将formattedNode映射到原始ID，因为childrenMap使用原始ID作为键\n  const formattedNodeToOriginalIdMap = new Map();\n  nodeMap.forEach((nodeInfo, originalId) => {\n    if (nodeInfo.formatted) {\n      formattedNodeToOriginalIdMap.set(nodeInfo.formatted, originalId);\n    }\n  });\n  \n  const stack2: any[] = [...roots];\n  while (stack2.length > 0) {\n    const formattedNode = stack2.pop();\n    \n    // 获取当前节点的原始ID\n    const originalId = formattedNodeToOriginalIdMap.get(formattedNode);\n    \n    // 构建子节点列表，使用childrenMap获取子节点\n    const children: any[] = [];\n    const childInfos = childrenMap.get(originalId) || [];\n    for (const childInfo of childInfos) {\n      if (childInfo.formatted) {\n        children.push(childInfo.formatted);\n        stack2.push(childInfo.formatted);\n      }\n    }\n    \n    // 更新当前节点的子节点列表\n    formattedNode[childrenKey] = children;\n  }\n\n  // 计算性能统计\n  const endTime = performance.now();\n  const endMemory = process.memoryUsage?.()?.heapUsed || 0;\n  \n  stats.buildTime = endTime - startTime;\n  stats.memoryUsed = (endMemory - startMemory) / (1024 * 1024); // 转换为MB\n\n  // 将统计信息添加到结果树中\n  (roots as any).__stats = stats;\n\n  // 返回结果\n  return roots;\n}\n\n","import { TreeBuilderConfig } from './types';\n\n/**\n * 最小化树形构建器（对标 row-to-tree）\n * 时间复杂度: O(n)，空间复杂度: O(n)\n */\nexport function buildMinimalTree<T = any>(\n  list: T[],\n  options: TreeBuilderConfig<T> = {}\n): any[] {\n  // 合并配置\n  const config: Required<TreeBuilderConfig> = {\n    idKey: 'id',\n    parentKey: 'parentId',\n    childrenKey: 'children',\n    rootParentId: 0,\n    enableGhostNodes: false,\n    validateNodes: true,\n    maxDepth: 1000,\n    enableCache: false,\n    ...options\n  };\n\n  // 空列表检查\n  if (!Array.isArray(list) || list.length === 0) {\n    return [];\n  }\n\n  const map = new Map<string | number, any>();\n  const roots: any[] = [];\n\n  // 第一遍：创建所有节点\n  for (const item of list) {\n    const id = (item as any)[config.idKey];\n    \n    // 验证节点ID\n    if (config.validateNodes && (id === undefined || id === null)) {\n      console.warn(`节点缺少ID字段 \"${config.idKey}\"，将被忽略:`, item);\n      continue;\n    }\n\n    // 检查重复ID\n    if (map.has(id)) {\n      console.warn(`发现重复ID \"${id}\"，后一个节点将覆盖前一个`);\n    }\n\n    map.set(id, {\n      ...item,\n      [config.childrenKey]: []\n    });\n  }\n\n  // 第二遍：建立父子关系\n  const processedIds = new Set<string | number>();\n  for (const item of list) {\n    const id = (item as any)[config.idKey];\n    const parentId = (item as any)[config.parentKey];\n    \n    const node = map.get(id);\n    if (!node) continue;\n\n    // 如果这个ID已经处理过，跳过（避免重复ID被多次处理）\n    if (processedIds.has(id)) {\n      continue;\n    }\n    processedIds.add(id);\n\n    // 判断是否为根节点\n    const isRoot = parentId === null || \n                  parentId === undefined || \n                  parentId === config.rootParentId;\n\n    if (isRoot) {\n      roots.push(node);\n    } else {\n      const parent = map.get(parentId);\n      \n      if (parent) {\n        // 正常父子关系\n        parent[config.childrenKey].push(node);\n      } else if (config.enableGhostNodes) {\n        // 创建幽灵节点\n        const ghostNode = { \n          [config.idKey]: parentId, \n          [config.childrenKey]: [node],\n          __isGhost: true \n        };\n        map.set(parentId, ghostNode);\n        roots.push(ghostNode);\n      } else {\n        // 父节点不存在，作为根节点\n        console.warn(`父节点 \"${parentId}\" 不存在，节点 \"${id}\" 将被作为根节点`);\n        roots.push(node);\n      }\n    }\n  }\n\n  return roots;\n}\n\n/**\n * 验证最小树的有效性\n */\nexport function validateMinimalTree(tree: any[], config: TreeBuilderConfig = {}): boolean {\n  const visited = new Set<string | number>();\n  const childrenKey = config.childrenKey || 'children';\n  \n  function validateNode(node: any, depth: number): boolean {\n    const id = node[config.idKey || 'id'];\n    \n    // 检查循环引用\n    if (visited.has(id)) {\n      console.error(`发现循环引用，节点ID: ${id}`);\n      return false;\n    }\n    \n    visited.add(id);\n    \n    // 检查深度限制\n    if (depth > (config.maxDepth || 1000)) {\n      console.error(`树深度超过限制: ${depth}`);\n      return false;\n    }\n    \n    // 递归检查子节点\n    const children = node[childrenKey];\n    if (Array.isArray(children)) {\n      for (const child of children) {\n        if (!validateNode(child, depth + 1)) {\n          return false;\n        }\n      }\n    }\n    \n    visited.delete(id);\n    return true;\n  }\n  \n  try {\n    for (const node of tree) {\n      if (!validateNode(node, 1)) {\n        return false;\n      }\n    }\n    return true;\n  } catch (error) {\n    console.error('树验证失败:', error);\n    return false;\n  }\n}"],"names":["list","options","formatCallback","idKey","parentKey","childrenKey","rootParentId","enableGhostNodes","validateNodes","maxDepth","detectCycles","onCycleDetected","node","path","console","warn","join","sortChildren","formatNode","isRootNode","startTime","performance","now","startMemory","process","memoryUsage","heapUsed","stats","totalNodes","rootNodes","buildTime","memoryUsed","cyclesDetected","ghostNodesCreated","Array","isArray","length","nodeMap","Map","item","id","parentId","set","original","formatted","children","depth","size","visited","Set","recursionStack","dfs","has","cycleStartIndex","indexOf","cyclePath","slice","get","add","push","nodeInfo","delete","pop","forEach","childrenMap","ghostId","ghostInfo","isGhost","roots","stack","processedNodeIds","isRoot","sort","a","b","i","parentFormatted","Math","max","nodeId","safeParent","context","level","isLeaf","parent","childCount","formattedNode","__isGhost","__parentId","error","childInfo","childId","childPath","childDepth","formattedNodeToOriginalIdMap","originalId","stack2","childInfos","endTime","endMemory","__stats","config","enableCache","map","processedIds","ghostNode","tree","validateNode","child"],"mappings":"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"}