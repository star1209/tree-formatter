{"version":3,"file":"index.js","sources":["../../src/core/minimal.ts","../../src/core/enhanced.ts","../../src/builder/strategies.ts","../../src/builder/incremental.ts","../../src/builder/smart.ts"],"sourcesContent":["import { TreeBuilderConfig } from './types';\n\n/**\n * 最小化树形构建器（对标 row-to-tree）\n * 时间复杂度: O(n)，空间复杂度: O(n)\n */\nexport function buildMinimalTree<T = any>(\n  list: T[],\n  options: TreeBuilderConfig<T> = {}\n): any[] {\n  // 合并配置\n  const config: Required<TreeBuilderConfig> = {\n    idKey: 'id',\n    parentKey: 'parentId',\n    childrenKey: 'children',\n    rootParentId: 0,\n    enableGhostNodes: false,\n    validateNodes: true,\n    maxDepth: 1000,\n    enableCache: false,\n    ...options\n  };\n\n  // 空列表检查\n  if (!Array.isArray(list) || list.length === 0) {\n    return [];\n  }\n\n  const map = new Map<string | number, any>();\n  const roots: any[] = [];\n\n  // 第一遍：创建所有节点\n  for (const item of list) {\n    const id = (item as any)[config.idKey];\n    \n    // 验证节点ID\n    if (config.validateNodes && (id === undefined || id === null)) {\n      console.warn(`节点缺少ID字段 \"${config.idKey}\"，将被忽略:`, item);\n      continue;\n    }\n\n    // 检查重复ID\n    if (map.has(id)) {\n      console.warn(`发现重复ID \"${id}\"，后一个节点将覆盖前一个`);\n    }\n\n    map.set(id, {\n      ...item,\n      [config.childrenKey]: []\n    });\n  }\n\n  // 第二遍：建立父子关系\n  const processedIds = new Set<string | number>();\n  for (const item of list) {\n    const id = (item as any)[config.idKey];\n    const parentId = (item as any)[config.parentKey];\n    \n    const node = map.get(id);\n    if (!node) continue;\n\n    // 如果这个ID已经处理过，跳过（避免重复ID被多次处理）\n    if (processedIds.has(id)) {\n      continue;\n    }\n    processedIds.add(id);\n\n    // 判断是否为根节点\n    const isRoot = parentId === null || \n                  parentId === undefined || \n                  parentId === config.rootParentId;\n\n    if (isRoot) {\n      roots.push(node);\n    } else {\n      const parent = map.get(parentId);\n      \n      if (parent) {\n        // 正常父子关系\n        parent[config.childrenKey].push(node);\n      } else if (config.enableGhostNodes) {\n        // 创建幽灵节点\n        const ghostNode = { \n          [config.idKey]: parentId, \n          [config.childrenKey]: [node],\n          __isGhost: true \n        };\n        map.set(parentId, ghostNode);\n        roots.push(ghostNode);\n      } else {\n        // 父节点不存在，作为根节点\n        console.warn(`父节点 \"${parentId}\" 不存在，节点 \"${id}\" 将被作为根节点`);\n        roots.push(node);\n      }\n    }\n  }\n\n  return roots;\n}\n\n/**\n * 验证最小树的有效性\n */\nexport function validateMinimalTree(tree: any[], config: TreeBuilderConfig = {}): boolean {\n  const visited = new Set<string | number>();\n  const childrenKey = config.childrenKey || 'children';\n  \n  function validateNode(node: any, depth: number): boolean {\n    const id = node[config.idKey || 'id'];\n    \n    // 检查循环引用\n    if (visited.has(id)) {\n      console.error(`发现循环引用，节点ID: ${id}`);\n      return false;\n    }\n    \n    visited.add(id);\n    \n    // 检查深度限制\n    if (depth > (config.maxDepth || 1000)) {\n      console.error(`树深度超过限制: ${depth}`);\n      return false;\n    }\n    \n    // 递归检查子节点\n    const children = node[childrenKey];\n    if (Array.isArray(children)) {\n      for (const child of children) {\n        if (!validateNode(child, depth + 1)) {\n          return false;\n        }\n      }\n    }\n    \n    visited.delete(id);\n    return true;\n  }\n  \n  try {\n    for (const node of tree) {\n      if (!validateNode(node, 1)) {\n        return false;\n      }\n    }\n    return true;\n  } catch (error) {\n    console.error('树验证失败:', error);\n    return false;\n  }\n}","import { EnhancedTreeConfig, NodeContext, BuildStats } from './types';\n\n/**\n * 增强树形构建器\n * 支持循环引用检测、节点排序、格式化等高级功能\n */\nexport function buildEnhancedTree<T = any, R = T>(\n  list: T[],\n  options: EnhancedTreeConfig<T> = {},\n  formatCallback?: (node: T, context: NodeContext) => R\n): R[] {\n  // 提取配置，分别处理每个属性\n  const idKey = options.idKey || 'id';\n  const parentKey = options.parentKey || 'parentId';\n  const childrenKey = options.childrenKey || 'children';\n  const rootParentId = options.rootParentId ?? 0;\n  const enableGhostNodes = options.enableGhostNodes || false;\n  const validateNodes = options.validateNodes !== false; // 默认为true\n  const maxDepth = options.maxDepth || 1000;\n  const detectCycles = options.detectCycles || false;\n  const onCycleDetected = options.onCycleDetected || ((node: T, path: (string | number)[]) => {\n    console.warn(`发现循环引用，路径: ${path.join(' -> ')}`);\n  });\n  const sortChildren = options.sortChildren;\n  const formatNode = options.formatNode;\n  const isRootNode = options.isRootNode;\n\n  // 性能监控\n  const startTime = performance.now();\n  const startMemory = process.memoryUsage?.()?.heapUsed || 0;\n  const stats: BuildStats = {\n    totalNodes: 0,\n    rootNodes: 0,\n    maxDepth: 0,\n    buildTime: 0,\n    memoryUsed: 0,\n    cyclesDetected: 0,\n    ghostNodesCreated: 0\n  };\n\n  // 空列表检查\n  if (!Array.isArray(list) || list.length === 0) {\n    return [];\n  }\n\n  // 节点映射表\n  const nodeMap = new Map<string | number, {\n    original: T;\n    formatted: any;\n    parentId: string | number | null;\n    children: any[];\n    depth: number;\n    isGhost?: boolean;\n  }>();\n\n  // 根节点列表\n  const roots: any[] = [];\n\n  // 第一步：收集所有节点\n  for (const item of list) {\n    const id = (item as any)[idKey];\n    const parentId = (item as any)[parentKey] ?? null;\n\n    // 验证节点\n    if (validateNodes && (id === undefined || id === null)) {\n      console.warn(`节点缺少ID字段 \"${idKey}\"，将被忽略:`, item);\n      continue;\n    }\n\n    // 检查自引用\n    if (id === parentId) {\n      if (detectCycles) {\n        onCycleDetected(item, [id]);\n        stats.cyclesDetected++;\n      }\n      continue;\n    }\n\n    // 创建格式化节点（如果需要）\n    const initialContext: NodeContext = {\n      level: 0,\n      path: [id],\n      isLeaf: true,\n      childCount: 0\n    };\n\n    let formattedNode: any;\n    if (formatCallback) {\n      formattedNode = formatCallback(item, initialContext);\n      formattedNode[childrenKey] = [];\n    } else if (formatNode) {\n      formattedNode = formatNode(item, initialContext);\n      formattedNode[childrenKey] = [];\n    } else {\n      formattedNode = {\n        ...item,\n        [childrenKey]: []\n      };\n    }\n\n    nodeMap.set(id, {\n      original: item,\n      formatted: formattedNode,\n      parentId,\n      children: [],\n      depth: 0\n    });\n  }\n\n  stats.totalNodes = nodeMap.size;\n\n  // 第二步：检测循环引用（如果需要）\n  if (detectCycles && nodeMap.size > 0) {\n    const cycles = detectCyclesInMap(nodeMap, idKey);\n    \n    cycles.forEach((cycle: (string | number)[]) => {\n      stats.cyclesDetected++;\n      const cycleNode = nodeMap.get(cycle[0]);\n      if (cycleNode) {\n        onCycleDetected(cycleNode.original, cycle);\n        nodeMap.delete(cycle[0]); // 移除环中的节点\n      }\n    });\n  }\n\n  // 第三步：建立父子关系\n  for (const [id, nodeInfo] of nodeMap) {\n    // 跳过幽灵节点，因为它们已经作为根节点添加了\n    if (nodeInfo.isGhost) {\n      continue;\n    }\n    const { parentId } = nodeInfo;\n\n    // 判断是否为根节点\n    const isRoot = parentId === null || \n              parentId === undefined || \n              parentId === rootParentId;\n\n    if (isRoot) {\n      roots.push(nodeInfo.formatted);\n      nodeInfo.depth = 1;\n      stats.rootNodes++;\n    } else {\n      const parentInfo = nodeMap.get(parentId!);\n      if (parentInfo) {\n        // 父节点存在，正常挂载\n        parentInfo.children.push(nodeInfo);\n        nodeInfo.formatted.__parentId = parentId;\n      } else {\n        // 父节点不存在\n        if (enableGhostNodes) {\n          // 检查是否已经存在这个幽灵节点（在 nodeMap 或 roots 中）\n          const existingGhostNode = nodeMap.get(parentId!);\n          if (existingGhostNode) {\n            // 幽灵节点已存在，直接将当前节点添加到其子节点\n            existingGhostNode.children.push(nodeInfo);\n            nodeInfo.formatted.__parentId = parentId;\n            nodeInfo.depth = existingGhostNode.depth + 1;\n          } else {\n            // 创建新的幽灵节点\n            const ghostNode = {\n              [idKey]: parentId,\n              [childrenKey]: [nodeInfo.formatted],\n              __isGhost: true,\n              __parentId: null\n            };\n            \n            const ghostInfo = {\n              original: { [idKey]: parentId } as T,\n              formatted: ghostNode,\n              parentId: null,\n              children: [nodeInfo],\n              depth: 1,\n              isGhost: true\n            };\n            \n            nodeMap.set(parentId!, ghostInfo);\n            roots.push(ghostNode);\n            nodeInfo.formatted.__parentId = parentId;\n            nodeInfo.depth = 2;\n            stats.ghostNodesCreated++;\n            stats.rootNodes++;\n          }\n          /* // 创建幽灵节点\n          const ghostNode = {\n            [idKey]: parentId,\n            [childrenKey]: [nodeInfo.formatted],\n            __isGhost: true,\n            __parentId: null\n          };\n          \n          const ghostInfo = {\n            original: { [idKey]: parentId } as T,\n            formatted: ghostNode,\n            parentId: null,\n            children: [nodeInfo],\n            depth: 1\n          };\n          \n          nodeMap.set(parentId!, ghostInfo);\n          roots.push(ghostNode); // 幽灵节点作为根节点\n          nodeInfo.formatted.__parentId = parentId;\n          nodeInfo.depth = 2;\n          stats.ghostNodesCreated++;\n          stats.rootNodes++; */\n        } else {\n          // 不启用幽灵节点，将当前节点作为根节点\n          roots.push(nodeInfo.formatted);\n          nodeInfo.depth = 1;\n          stats.rootNodes++;\n        }\n      }\n    }\n  }\n\n  // 第四步：深度优先计算层级和路径\n  const stack: Array<{\n    nodeInfo: any;\n    formattedNode: any;\n    depth: number;\n    path: (string | number)[];\n  }> = [];\n\n  // 初始化栈\n  roots.forEach(rootNode => {\n    const rootId = rootNode[idKey];\n    const nodeInfo = nodeMap.get(rootId);\n    if (nodeInfo) {\n      stack.push({\n        nodeInfo,\n        formattedNode: rootNode,\n        depth: 1,\n        path: [rootId]\n      });\n    }\n  });\n\n  while (stack.length > 0) {\n    const { nodeInfo, formattedNode, depth, path } = stack.pop()!;\n    \n    // 更新最大深度\n    stats.maxDepth = Math.max(stats.maxDepth, depth);\n    \n    // 检查深度限制\n    if (depth > maxDepth) {\n      console.warn(`节点 \"${path.join(' -> ')}\" 深度超过限制: ${depth}`);\n      continue;\n    }\n\n    // 处理子节点\n    const childrenInfos = nodeInfo.children;\n    \n    // 子节点排序\n    if (sortChildren && childrenInfos.length > 0) {\n      try {\n        childrenInfos.sort((a: any, b: any) => \n          sortChildren(a.original, b.original)\n        );\n      } catch (error) {\n        console.warn('子节点排序失败:', error);\n      }\n    }\n\n    // 构建子节点\n    const children: any[] = [];\n    for (const childInfo of childrenInfos) {\n      const childId = childInfo.original[idKey];\n      const childPath = [...path, childId];\n      const childDepth = depth + 1;\n      \n      // 更新子节点深度\n      childInfo.depth = childDepth;\n      \n      // 创建或获取格式化节点\n      let childFormatted = childInfo.formatted;\n      \n      // 计算子节点上下文\n      const childContext: NodeContext = {\n        level: childDepth,\n        path: childPath,\n        isLeaf: childInfo.children.length === 0,\n        parent: formattedNode,\n        childCount: childInfo.children.length\n      };\n      \n      // 应用格式化回调\n      if (formatCallback) {\n        childFormatted = {\n          ...formatCallback(childInfo.original, childContext),\n          [childrenKey]: []\n        };\n      } else if (formatNode) {\n        childFormatted = {\n          ...formatNode(childInfo.original, childContext),\n          [childrenKey]: []\n        };\n      }\n      \n      // 设置父ID引用\n      childFormatted.__parentId = nodeInfo.original[idKey];\n      \n      children.push(childFormatted);\n      childInfo.formatted = childFormatted;\n      \n      // 继续处理子节点的子节点\n      stack.push({\n        nodeInfo: childInfo,\n        formattedNode: childFormatted,\n        depth: childDepth,\n        path: childPath\n      });\n    }\n    \n    // 更新当前节点的子节点列表\n    formattedNode[childrenKey] = children;\n    \n    // 更新当前节点的上下文信息\n    const currentContext: NodeContext = {\n      level: depth,\n      path,\n      isLeaf: children.length === 0,\n      childCount: children.length\n    };\n    \n    // 重新格式化当前节点（如果需要）\n    if (formatCallback) {\n      Object.assign(formattedNode, formatCallback(nodeInfo.original, currentContext));\n      formattedNode[childrenKey] = children; // 保持子节点引用\n    } else if (formatNode) {\n      Object.assign(formattedNode, formatNode(nodeInfo.original, currentContext));\n      formattedNode[childrenKey] = children;\n    }\n  }\n\n  // 第五步：根节点排序\n  if (sortChildren && roots.length > 1) {\n    try {\n      roots.sort((a, b) => {\n        const aId = a[idKey];\n        const bId = b[idKey];\n        const aInfo = nodeMap.get(aId);\n        const bInfo = nodeMap.get(bId);\n        \n        if (aInfo && bInfo) {\n          return sortChildren(aInfo.original, bInfo.original);\n        }\n        return 0;\n      });\n    } catch (error) {\n      console.warn('根节点排序失败:', error);\n    }\n  }\n\n  // 计算性能统计\n  const endTime = performance.now();\n  const endMemory = process.memoryUsage?.()?.heapUsed || 0;\n  \n  stats.buildTime = endTime - startTime;\n  stats.memoryUsed = (endMemory - startMemory) / (1024 * 1024); // 转换为MB\n\n  // 添加统计信息到根节点\n  if (roots.length > 0) {\n    (roots as any).__stats = stats;\n  }\n\n  return roots;\n}\n\n/**\n * 循环引用检测函数\n */\nfunction detectCyclesInMap(\n  nodeMap: Map<string | number, any>,\n  idKey: string\n): (string | number)[][] {\n  const adjacency = new Map<string | number, Set<string | number>>();\n  const inDegree = new Map<string | number, number>();\n  \n  // 初始化图\n  nodeMap.forEach((nodeInfo, id) => {\n    adjacency.set(id, new Set());\n    inDegree.set(id, 0);\n  });\n  \n  // 构建边\n  nodeMap.forEach((nodeInfo, id) => {\n    const parentId = nodeInfo.parentId;\n    if (parentId !== null && nodeMap.has(parentId) && id !== parentId) {\n      adjacency.get(parentId)!.add(id);\n      inDegree.set(id, (inDegree.get(id) || 0) + 1);\n    }\n  });\n  \n  // Kahn算法检测环\n  const queue: (string | number)[] = [];\n  const cycles: (string | number)[][] = [];\n  \n  // 入度为0的节点入队\n  inDegree.forEach((degree, id) => {\n    if (degree === 0) {\n      queue.push(id);\n    }\n  });\n  \n  // 处理队列\n  while (queue.length > 0) {\n    const current = queue.shift()!;\n    \n    const neighbors = adjacency.get(current);\n    if (neighbors) {\n      neighbors.forEach(neighbor => {\n        const newDegree = (inDegree.get(neighbor) || 1) - 1;\n        inDegree.set(neighbor, newDegree);\n        \n        if (newDegree === 0) {\n          queue.push(neighbor);\n        }\n      });\n    }\n  }\n  \n  // 找出环中的节点\n  const visited = new Set<string | number>();\n  \n  inDegree.forEach((degree, id) => {\n    if (degree > 0 && !visited.has(id)) {\n      const cycle: (string | number)[] = [];\n      let current = id;\n      \n      while (!visited.has(current)) {\n        visited.add(current);\n        cycle.push(current);\n        \n        // 找到下一个在环中的节点\n        const neighbors = Array.from(adjacency.get(current) || []);\n        for (const neighbor of neighbors) {\n          if (inDegree.get(neighbor)! > 0 && !visited.has(neighbor)) {\n            current = neighbor;\n            break;\n          }\n        }\n      }\n      \n      if (cycle.length > 0) {\n        cycles.push(cycle);\n      }\n    }\n  });\n  \n  return cycles;\n}","import { TreeBuilderConfig } from '../core/types';\nimport { buildMinimalTree } from '../core/minimal';\nimport { buildEnhancedTree } from '../core/enhanced';\n\n/**\n * 构建策略接口\n */\nexport interface TreeBuilderStrategy<T = any> {\n  name: string;\n  description: string;\n  build(list: T[], config: TreeBuilderConfig<T>): any[];\n}\n\n/**\n * 最小化构建策略\n */\nexport class MinimalStrategy<T = any> implements TreeBuilderStrategy<T> {\n  readonly name = 'minimal';\n  readonly description = '最小化构建策略（对标 row-to-tree）';\n  \n  build(list: T[], config: TreeBuilderConfig<T>): any[] {\n    return buildMinimalTree(list, config);\n  }\n}\n\n/**\n * 增强构建策略\n */\nexport class EnhancedStrategy<T = any> implements TreeBuilderStrategy<T> {\n  readonly name = 'enhanced';\n  readonly description = '增强构建策略（支持循环检测、排序等）';\n  \n  build(list: T[], config: TreeBuilderConfig<T>): any[] {\n    return buildEnhancedTree(list, config as any);\n  }\n}\n\n/**\n * 递归构建策略\n */\nexport class RecursiveStrategy<T = any> implements TreeBuilderStrategy<T> {\n  readonly name = 'recursive';\n  readonly description = '递归构建策略（适合深度嵌套）';\n  \n  build(list: T[], config: TreeBuilderConfig<T>): any[] {\n    const idKey = config.idKey || 'id';\n    const parentKey = config.parentKey || 'parentId';\n    const childrenKey = config.childrenKey || 'children';\n    const rootParentId = config.rootParentId ?? 0;\n    \n    const nodeMap = new Map<string | number, any>();\n    const roots: any[] = [];\n    \n    // 创建所有节点\n    list.forEach(item => {\n      const id = (item as any)[idKey];\n      if (id !== undefined && id !== null) {\n        nodeMap.set(id, {\n          ...item,\n          [childrenKey]: []\n        });\n      }\n    });\n    \n    // 递归构建\n    const buildTree = (parentId: string | number | null = rootParentId): any[] => {\n      const children: any[] = [];\n      \n      list.forEach(item => {\n        const id = (item as any)[idKey];\n        const itemParentId = (item as any)[parentKey];\n        \n        if (itemParentId === parentId) {\n          const node = nodeMap.get(id);\n          if (node) {\n            const childNodes = buildTree(id);\n            node[childrenKey] = childNodes;\n            children.push(node);\n          }\n        }\n      });\n      \n      return children;\n    };\n    \n    return buildTree();\n  }\n}\n\n/**\n * 策略工厂\n */\nexport class StrategyFactory {\n  /**\n   * 根据数据特征选择构建策略\n   */\n  static selectStrategy<T>(\n    list: T[],\n    config: TreeBuilderConfig<T> = {}\n  ): TreeBuilderStrategy<T> {\n    const dataSize = list.length;\n    const needsAdvanced = config.enableGhostNodes || \n                         (config as any).detectCycles ||\n                         (config as any).sortChildren;\n    \n    // 小数据量使用最小策略\n    if (dataSize < 1000 && !needsAdvanced) {\n      return new MinimalStrategy<T>();\n    }\n    \n    // 需要高级功能或大数据量使用增强策略\n    if (dataSize >= 1000 || needsAdvanced) {\n      return new EnhancedStrategy<T>();\n    }\n    \n    // 默认使用最小策略\n    return new MinimalStrategy<T>();\n  }\n  \n  /**\n   * 获取所有可用策略\n   */\n  static getAllStrategies<T>(): TreeBuilderStrategy<T>[] {\n    return [\n      new MinimalStrategy<T>(),\n      new EnhancedStrategy<T>(),\n      new RecursiveStrategy<T>()\n    ];\n  }\n}","import { TreeBuilderConfig } from '../core/types';\n\n/**\n * 增量树形构建器\n * 支持增量添加、删除和更新节点\n */\nexport class IncrementalTreeBuilder<T = any> {\n  private tree: any[] = [];\n  private nodeMap = new Map<string | number, any>();\n  private config: Required<TreeBuilderConfig<T>>;\n  \n  constructor(config: TreeBuilderConfig<T> = {}) {\n    this.config = {\n      idKey: 'id',\n      parentKey: 'parentId',\n      childrenKey: 'children',\n      rootParentId: 0,\n      enableGhostNodes: false,\n      validateNodes: true,\n      maxDepth: 1000,\n      enableCache: false,\n      ...config\n    };\n  }\n  \n  /**\n   * 增量添加节点\n   */\n  addNode(nodeData: T): this {\n    const id = (nodeData as any)[this.config.idKey];\n    const parentId = (nodeData as any)[this.config.parentKey] ?? null;\n    \n    if (this.nodeMap.has(id)) {\n      console.warn(`节点 ${id} 已存在，将更新该节点`);\n      return this.updateNode(id, nodeData);\n    }\n    \n    // 创建节点\n    const newNode = {\n      ...nodeData,\n      [this.config.childrenKey]: []\n    };\n    \n    this.nodeMap.set(id, newNode);\n    \n    // 判断是否为根节点\n    const isRoot = parentId === null || \n                  parentId === undefined || \n                  parentId === this.config.rootParentId ||\n                  !this.nodeMap.has(parentId);\n    \n    if (isRoot) {\n      this.tree.push(newNode);\n    } else {\n      const parentNode = this.nodeMap.get(parentId);\n      if (parentNode) {\n        parentNode[this.config.childrenKey].push(newNode);\n      } else if (this.config.enableGhostNodes) {\n        // 创建幽灵节点\n        const ghostNode = {\n          [this.config.idKey]: parentId,\n          [this.config.childrenKey]: [newNode],\n          __isGhost: true\n        };\n        this.nodeMap.set(parentId, ghostNode);\n        this.tree.push(ghostNode);\n      } else {\n        // 父节点不存在，作为根节点\n        this.tree.push(newNode);\n      }\n    }\n    \n    return this;\n  }\n  \n  /**\n   * 批量添加节点\n   */\n  addNodes(nodes: T[]): this {\n    nodes.forEach(node => this.addNode(node));\n    return this;\n  }\n  \n  /**\n   * 删除节点\n   */\n  removeNode(id: string | number): this {\n    const node = this.nodeMap.get(id);\n    if (!node) {\n      console.warn(`节点 ${id} 不存在`);\n      return this;\n    }\n    \n    // 从父节点中移除\n    const parentId = node.__parentId;\n    if (parentId) {\n      const parentNode = this.nodeMap.get(parentId);\n      if (parentNode && parentNode[this.config.childrenKey]) {\n        const index = parentNode[this.config.childrenKey].findIndex(\n          (child: any) => child[this.config.idKey] === id\n        );\n        if (index !== -1) {\n          parentNode[this.config.childrenKey].splice(index, 1);\n        }\n      }\n    } else {\n      // 从根节点中移除\n      const index = this.tree.findIndex(\n        (rootNode) => rootNode[this.config.idKey] === id\n      );\n      if (index !== -1) {\n        this.tree.splice(index, 1);\n      }\n    }\n    \n    // 递归删除子节点\n    const removeChildren = (node: any) => {\n      if (node[this.config.childrenKey]) {\n        node[this.config.childrenKey].forEach((child: any) => {\n          const childId = child[this.config.idKey];\n          this.nodeMap.delete(childId);\n          removeChildren(child);\n        });\n      }\n    };\n    \n    removeChildren(node);\n    this.nodeMap.delete(id);\n    \n    return this;\n  }\n  \n  /**\n   * 更新节点\n   */\n  updateNode(id: string | number, updates: Partial<T>): this {\n    const node = this.nodeMap.get(id);\n    if (!node) {\n      console.warn(`节点 ${id} 不存在，将尝试添加`);\n      return this.addNode({ [this.config.idKey]: id, ...updates } as T);\n    }\n    \n    Object.assign(node, updates);\n    \n    // 如果更新了父节点，需要重新挂载\n    const newParentId = (updates as any)[this.config.parentKey];\n    if (newParentId !== undefined && newParentId !== node.__parentId) {\n      this.removeNode(id);\n      return this.addNode({ ...node, ...updates });\n    }\n    \n    return this;\n  }\n  \n  /**\n   * 查找节点\n   */\n  findNode(id: string | number): any | undefined {\n    return this.nodeMap.get(id);\n  }\n  \n  /**\n   * 获取完整树\n   */\n  getTree(): any[] {\n    return this.tree;\n  }\n  \n  /**\n   * 重置构建器\n   */\n  reset(): this {\n    this.tree = [];\n    this.nodeMap.clear();\n    return this;\n  }\n  \n  /**\n   * 获取节点数量\n   */\n  getNodeCount(): number {\n    return this.nodeMap.size;\n  }\n  \n  /**\n   * 获取根节点数量\n   */\n  getRootCount(): number {\n    return this.tree.length;\n  }\n}","import { TreeBuilderConfig, TreePlugin, BuildStats } from '../core/types';\nimport { buildMinimalTree } from '../core/minimal';\nimport { buildEnhancedTree } from '../core/enhanced';\n\n/**\n * 智能树形构建器\n * 根据数据特征自动选择最优构建策略\n */\nexport class SmartTreeBuilder<T = any> {\n  private plugins: TreePlugin<T>[] = [];\n  private config: TreeBuilderConfig<T>;\n  private cache = new Map<string, any>();\n  private stats: BuildStats[] = [];\n\n  constructor(config: TreeBuilderConfig<T> = {}) {\n    this.config = {\n      idKey: 'id',\n      parentKey: 'parentId',\n      childrenKey: 'children',\n      rootParentId: 0,\n      enableGhostNodes: false,\n      validateNodes: true,\n      maxDepth: 1000,\n      enableCache: false,\n      ...config\n    };\n  }\n\n  /**\n   * 注册插件\n   */\n  use(plugin: TreePlugin<T>): this {\n    this.plugins.push(plugin);\n    // 按优先级排序\n    this.plugins.sort((a, b) => (a.priority || 100) - (b.priority || 100));\n    return this;\n  }\n\n  /**\n   * 构建树形结构\n   */\n  build(list: T[]): any[] {\n    // 处理空输入\n    if (!list) {\n      return [];\n    }\n    const startTime = performance.now();\n    \n    // 生成缓存键\n    const cacheKey = this.generateCacheKey(list);\n    \n    // 检查缓存\n    if (this.config.enableCache && this.cache.has(cacheKey)) {\n      console.log('使用缓存结果');\n      const cached = this.cache.get(cacheKey);\n  \n      // 为缓存命中记录统计信息\n      const cacheStats: BuildStats = {\n        totalNodes: list.length,\n        rootNodes: cached?.length || 0,\n        maxDepth: this.calculateMaxDepth(cached || []),\n        buildTime: 0, // 缓存命中，构建时间为0\n        memoryUsed: 0,\n        cyclesDetected: 0,\n        ghostNodesCreated: 0,\n        cacheHit: true // 添加缓存命中标记\n      };\n      \n      this.stats.push(cacheStats);\n      return cached;\n    }\n\n    // 选择构建策略\n    const strategy = this.selectStrategy(list);\n    console.log(`选择构建策略: ${strategy.name}`);\n    \n    let tree: any[];\n    \n    // 应用前置插件\n    const beforeResult = this.applyBeforeBuild(list);\n    const processedList = beforeResult ? beforeResult : list;\n    \n    // 执行构建\n    switch (strategy.name) {\n      case 'minimal':\n        tree = buildMinimalTree(processedList, this.config);\n        break;\n      case 'enhanced':\n        tree = buildEnhancedTree(processedList, this.config as any);\n        break;\n      case 'incremental':\n        tree = this.buildIncremental(processedList);\n        break;\n      default:\n        tree = buildMinimalTree(processedList, this.config);\n    }\n    \n    // 应用后置插件\n    tree = this.applyAfterBuild(tree, list);\n    \n    // 更新统计信息\n    const endTime = performance.now();\n    const buildStats: BuildStats = {\n      totalNodes: list.length,\n      rootNodes: tree.length,\n      maxDepth: this.calculateMaxDepth(tree),\n      buildTime: endTime - startTime,\n      memoryUsed: this.getMemoryUsage(),\n      cyclesDetected: 0,\n      ghostNodesCreated: 0\n    };\n    \n    this.stats.push(buildStats);\n    \n    // 缓存结果\n    if (this.config.enableCache) {\n      this.cache.set(cacheKey, tree);\n    }\n    \n    // 添加统计信息\n    (tree as any).__stats = buildStats;\n    \n    return tree;\n  }\n\n  /**\n   * 获取构建统计信息\n   */\n  getStats(): BuildStats[] {\n    return this.stats;\n  }\n\n  /**\n   * 清除缓存\n   */\n  clearCache(): void {\n    this.cache.clear();\n  }\n\n  /**\n   * 重置构建器状态\n   */\n  reset(): void {\n    this.plugins = [];\n    this.cache.clear();\n    this.stats = [];\n  }\n\n  /**\n   * 生成缓存键\n   */\n  private generateCacheKey(list: T[]): string {\n    const configStr = JSON.stringify(this.config);\n  \n    // 处理 null 或 undefined 的情况\n    if (!list) {\n      return `${configStr}:null:0`;\n    }\n    \n    const listStr = JSON.stringify(list.slice(0, Math.min(10, list.length)));\n    return `${configStr}:${listStr}:${list.length}`;\n  }\n\n  /**\n   * 根据数据特征选择构建策略\n   */\n  private selectStrategy(list: T[]): { name: string; description: string } {\n    // 数据量小于1000，使用最小化构建\n    if (list.length < 1000) {\n      return { name: 'minimal', description: '最小化构建策略' };\n    }\n    \n    // 检查是否需要高级功能\n    const needsAdvanced = this.plugins.length > 0 || \n                         this.config.enableGhostNodes ||\n                         this.config.maxDepth !== 1000;\n    \n    if (needsAdvanced) {\n      return { name: 'enhanced', description: '增强构建策略' };\n    }\n    \n    // 数据量很大且结构简单，使用最小化构建\n    return { name: 'minimal', description: '最小化构建策略' };\n  }\n\n  /**\n   * 应用前置插件\n   */\n  private applyBeforeBuild(list: T[]): T[] | void {\n    let result: T[] = list;\n    \n    for (const plugin of this.plugins) {\n      if (plugin.onNodeCreated) {\n        // 创建节点时应用插件\n        result = result.map((item, index) => {\n          const context = {\n            level: 0,\n            path: [(item as any)[this.config.idKey || 'id']],\n            isLeaf: true,\n            childCount: 0\n          };\n          \n          plugin.onNodeCreated?.(item, context);\n          return item;\n        });\n      }\n    }\n    \n    return result;\n  }\n\n  /**\n   * 应用后置插件\n   */\n  private applyAfterBuild(tree: any[], originalList: T[]): any[] {\n    let result = tree;\n    \n    for (const plugin of this.plugins) {\n      if (plugin.onTreeBuilt) {\n        const pluginResult = plugin.onTreeBuilt(result, { originalList });\n        if (pluginResult) {\n          result = pluginResult;\n        }\n      }\n    }\n    \n    return result;\n  }\n\n  /**\n   * 增量构建（简化版）\n   */\n  private buildIncremental(list: T[]): any[] {\n    // 简化的增量构建实现\n    const tree = buildMinimalTree(list, this.config);\n    \n    // 应用增量优化\n    this.optimizeTreeStructure(tree);\n    \n    return tree;\n  }\n\n  /**\n   * 优化树结构\n   */\n  private optimizeTreeStructure(tree: any[]): void {\n    // 优化算法：扁平化深度嵌套\n    this.flattenDeepNesting(tree, this.config.maxDepth || 1000);\n  }\n\n  /**\n   * 扁平化深度嵌套\n   */\n  private flattenDeepNesting(tree: any[], maxDepth: number): void {\n    const childrenKey = this.config.childrenKey || 'children';\n    \n    function flatten(node: any, depth: number): any {\n      if (depth >= maxDepth && node[childrenKey]?.length > 0) {\n        // 将深层子节点提升为兄弟节点\n        const flattened = {\n          ...node,\n          [childrenKey]: []\n        };\n        \n        // 递归处理子节点\n        const processChildren = (children: any[], currentDepth: number) => {\n          for (const child of children) {\n            if (currentDepth >= maxDepth) {\n              // 提升为兄弟节点\n              tree.push(child);\n            } else {\n              flattened[childrenKey].push(child);\n            }\n            processChildren(child[childrenKey] || [], currentDepth + 1);\n          }\n        };\n        \n        processChildren(node[childrenKey] || [], depth);\n        return flattened;\n      }\n      \n      return node;\n    }\n    \n    for (let i = 0; i < tree.length; i++) {\n      tree[i] = flatten(tree[i], 1);\n    }\n  }\n\n  /**\n   * 计算树的最大深度\n   */\n  private calculateMaxDepth(tree: any[]): number {\n    const childrenKey = this.config.childrenKey || 'children';\n    let maxDepth = 0;\n    \n    function calculate(node: any, depth: number): void {\n      maxDepth = Math.max(maxDepth, depth);\n      \n      const children = node[childrenKey];\n      if (Array.isArray(children)) {\n        for (const child of children) {\n          calculate(child, depth + 1);\n        }\n      }\n    }\n    \n    for (const node of tree) {\n      calculate(node, 1);\n    }\n    \n    return maxDepth;\n  }\n\n  /**\n   * 获取内存使用情况\n   */\n  private getMemoryUsage(): number {\n    if (typeof process !== 'undefined' && process.memoryUsage) {\n      const usage = process.memoryUsage();\n      return usage.heapUsed / 1024 / 1024; // MB\n    }\n    return 0;\n  }\n}"],"names":["buildMinimalTree","list","options","config","idKey","parentKey","childrenKey","rootParentId","enableGhostNodes","validateNodes","maxDepth","enableCache","Array","isArray","length","map","Map","roots","item","id","console","warn","has","set","processedIds","Set","parentId","node","get","add","push","parent","ghostNode","__isGhost","buildEnhancedTree","formatCallback","detectCycles","onCycleDetected","path","join","sortChildren","formatNode","isRootNode","startTime","performance","now","startMemory","process","memoryUsage","heapUsed","stats","totalNodes","rootNodes","buildTime","memoryUsed","cyclesDetected","ghostNodesCreated","nodeMap","initialContext","level","isLeaf","childCount","formattedNode","original","formatted","children","depth","size","cycles","adjacency","inDegree","forEach","nodeInfo","queue","degree","current","shift","neighbors","neighbor","newDegree","visited","cycle","from","detectCyclesInMap","cycleNode","delete","isGhost","parentInfo","__parentId","existingGhostNode","ghostInfo","stack","rootNode","rootId","pop","Math","max","childrenInfos","sort","a","b","error","childInfo","childId","childPath","childDepth","childFormatted","childContext","currentContext","Object","assign","aId","bId","aInfo","bInfo","endTime","endMemory","__stats","MinimalStrategy","constructor","this","name","description","build","EnhancedStrategy","RecursiveStrategy","buildTree","childNodes","tree","addNode","nodeData","updateNode","newNode","parentNode","addNodes","nodes","removeNode","index","findIndex","child","splice","removeChildren","updates","newParentId","undefined","findNode","getTree","reset","clear","getNodeCount","getRootCount","plugins","cache","use","plugin","priority","cacheKey","generateCacheKey","log","cached","cacheStats","calculateMaxDepth","cacheHit","strategy","selectStrategy","beforeResult","applyBeforeBuild","processedList","buildIncremental","applyAfterBuild","buildStats","getMemoryUsage","getStats","clearCache","configStr","JSON","stringify","slice","min","result","onNodeCreated","context","originalList","onTreeBuilt","pluginResult","optimizeTreeStructure","flattenDeepNesting","flatten","flattened","processChildren","currentDepth","i","calculate","dataSize","needsAdvanced","getAllStrategies"],"mappings":"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"}