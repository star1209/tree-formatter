function e(e,t={}){const o={idKey:"id",parentKey:"parentId",childrenKey:"children",rootParentId:0,enableGhostNodes:!1,validateNodes:!0,maxDepth:1e3,enableCache:!1,...t};if(!Array.isArray(e)||0===e.length)return[];const n=new Map,r=[];for(const t of e){const e=t[o.idKey];o.validateNodes&&null==e?console.warn(`节点缺少ID字段 "${o.idKey}"，将被忽略:`,t):(n.has(e)&&console.warn(`发现重复ID "${e}"，后一个节点将覆盖前一个`),n.set(e,{...t,[o.childrenKey]:[]}))}const s=new Set;for(const t of e){const e=t[o.idKey],i=t[o.parentKey],d=n.get(e);if(!d)continue;if(s.has(e))continue;s.add(e);if(null==i||i===o.rootParentId)r.push(d);else{const t=n.get(i);if(t)t[o.childrenKey].push(d);else if(o.enableGhostNodes){const e={[o.idKey]:i,[o.childrenKey]:[d],__isGhost:!0};n.set(i,e),r.push(e)}else console.warn(`父节点 "${i}" 不存在，节点 "${e}" 将被作为根节点`),r.push(d)}}return r}function t(e,t={}){const o=new Set,n=t.childrenKey||"children";function r(e,s){const i=e[t.idKey||"id"];if(o.has(i))return console.error(`发现循环引用，节点ID: ${i}`),!1;if(o.add(i),s>(t.maxDepth||1e3))return console.error(`树深度超过限制: ${s}`),!1;const d=e[n];if(Array.isArray(d))for(const e of d)if(!r(e,s+1))return!1;return o.delete(i),!0}try{for(const t of e)if(!r(t,1))return!1;return!0}catch(e){return console.error("树验证失败:",e),!1}}function o(e,t={},o){const n=t.idKey||"id",r=t.parentKey||"parentId",s=t.childrenKey||"children",i=t.rootParentId??0,d=t.enableGhostNodes||!1,a=!1!==t.validateNodes,c=t.maxDepth||1e3,l=t.detectCycles||!1,h=t.onCycleDetected||((e,t)=>{console.warn(`发现循环引用，路径: ${t.join(" -> ")}`)}),f=t.sortChildren,p=t.formatNode;t.isRootNode;const u=performance.now(),g=process.memoryUsage?.()?.heapUsed||0,y={totalNodes:0,rootNodes:0,maxDepth:0,buildTime:0,memoryUsed:0,cyclesDetected:0,ghostNodesCreated:0};if(!Array.isArray(e)||0===e.length)return[];const m=new Map,I=[];for(const t of e){const e=t[n],i=t[r]??null;if(a&&null==e){console.warn(`节点缺少ID字段 "${n}"，将被忽略:`,t);continue}if(e===i){l&&(h(t,[e]),y.cyclesDetected++);continue}const d={level:0,path:[e],isLeaf:!0,childCount:0};let c;o?(c=o(t,d),c[s]=[]):p?(c=p(t,d),c[s]=[]):c={...t,[s]:[]},m.set(e,{original:t,formatted:c,parentId:i,children:[],depth:0})}if(y.totalNodes=m.size,l&&m.size>0){!function(e){const t=[],o=new Set,n=new Set,r=[];function s(i){if(n.has(i)){const e=r.indexOf(i);return void(-1!==e&&t.push(r.slice(e)))}if(o.has(i))return;o.add(i),n.add(i),r.push(i);const d=e.get(i);if(d){const t=d.parentId;null!==t&&e.has(t)&&i!==t&&s(t)}n.delete(i),r.pop()}e.forEach((e,t)=>{o.has(t)||s(t)})}(m);for(const[e,t]of m)t.parentId===e&&(y.cyclesDetected++,h(t.original,[e]),m.delete(e))}for(const[e,t]of m){if(t.isGhost)continue;const{parentId:e}=t;if(null==e||e===i)I.push(t.formatted),t.depth=1,y.rootNodes++;else{const o=m.get(e);if(o)o.children.push(t),t.formatted.__parentId=e;else if(d){const o=m.get(e);if(o)o.children.push(t),t.formatted.__parentId=e,t.depth=o.depth+1;else{const o={[n]:e,[s]:[t.formatted],__isGhost:!0,__parentId:null},r={original:{[n]:e},formatted:o,parentId:null,children:[t],depth:1,isGhost:!0};m.set(e,r),I.push(o),t.formatted.__parentId=e,t.depth=2,y.ghostNodesCreated++,y.rootNodes++}}else I.push(t.formatted),t.depth=1,y.rootNodes++}}const N=[];for(I.forEach(e=>{const t=e[n],o=m.get(t);o&&N.push({nodeInfo:o,formattedNode:e,depth:1,path:[t]})});N.length>0;){const{nodeInfo:e,formattedNode:t,depth:r,path:i}=N.pop();if(y.maxDepth=Math.max(y.maxDepth,r),r>c){console.warn(`节点 "${i.join(" -> ")}" 深度超过限制: ${r}`);continue}const d=e.children;if(f&&d.length>0)try{d.sort((e,t)=>f(e.original,t.original))}catch(e){console.warn("子节点排序失败:",e)}const a=[];for(const c of d){const d=c.original[n],l=[...i,d],h=r+1;c.depth=h;let f=c.formatted;const u={level:h,path:l,isLeaf:0===c.children.length,parent:t,childCount:c.children.length};o?f={...o(c.original,u),[s]:[]}:p&&(f={...p(c.original,u),[s]:[]}),f.__parentId=e.original[n],a.push(f),c.formatted=f,N.push({nodeInfo:c,formattedNode:f,depth:h,path:l})}t[s]=a;const l={level:r,path:i,isLeaf:0===a.length,childCount:a.length};o?(Object.assign(t,o(e.original,l)),t[s]=a):p&&(Object.assign(t,p(e.original,l)),t[s]=a)}if(f&&I.length>1)try{I.sort((e,t)=>{const o=e[n],r=t[n],s=m.get(o),i=m.get(r);return s&&i?f(s.original,i.original):0})}catch(e){console.warn("根节点排序失败:",e)}const w=performance.now(),K=process.memoryUsage?.()?.heapUsed||0;return y.buildTime=w-u,y.memoryUsed=(K-g)/1048576,I.length>0&&(I.__stats=y),I}export{o as buildEnhancedTree,e as buildMinimalTree,t as validateMinimalTree};
//# sourceMappingURL=index.esm.js.map
