"use strict";exports.buildEnhancedTree=function(e,t={},o){const n=t.idKey||"id",r=t.parentKey||"parentId",s=t.childrenKey||"children",i=t.rootParentId??0,a=t.enableGhostNodes||!1,d=!1!==t.validateNodes,c=t.maxDepth||1e3,l=t.detectCycles||!1,h=t.onCycleDetected||((e,t)=>{console.warn(`发现循环引用，路径: ${t.join(" -> ")}`)}),f=t.sortChildren,p=t.formatNode,u=t.isRootNode,g=performance.now(),m=process.memoryUsage?.()?.heapUsed||0,y={totalNodes:0,rootNodes:0,maxDepth:0,buildTime:0,memoryUsed:0,cyclesDetected:0,ghostNodesCreated:0};if(!Array.isArray(e)||0===e.length)return[];const I=new Map,N=[];for(const t of e){const e=t[n],i=t[r]??null;if(d&&null==e){console.warn(`节点缺少ID字段 "${n}"，将被忽略:`,t);continue}if(e===i){l&&(h(t,[e]),y.cyclesDetected++);continue}const a={level:0,path:[e],isLeaf:!0,childCount:0};let c;o?(c=o(t,a),c[s]=[]):p?(c=p(t,a),c[s]=[]):c={...t,[s]:[]},I.set(e,{original:t,formatted:c,parentId:i,children:[],depth:0})}if(y.totalNodes=I.size,l&&I.size>0){const e=new Set;for(const[t,o]of I)o.parentId===t&&(y.cyclesDetected++,h(o.original,[t]),e.add(t));e.forEach(e=>{I.delete(e)})}for(const[e,t]of I){if(t.isGhost)continue;const{parentId:e}=t;if(u?u(t.original):null==e||e===i)N.push(t.formatted),t.depth=1,y.rootNodes++;else{const o=I.get(e);if(o)o.children.push(t),t.formatted.__parentId=e;else if(a){const o=I.get(e);if(o)o.children.push(t),t.formatted.__parentId=e,t.depth=o.depth+1;else{const o={[n]:e,[s]:[t.formatted],__isGhost:!0,__parentId:null},r={original:{[n]:e},formatted:o,parentId:null,children:[t],depth:1,isGhost:!0};I.set(e,r),N.push(o),t.formatted.__parentId=e,t.depth=2,y.ghostNodesCreated++,y.rootNodes++}}else N.push(t.formatted),t.depth=1,y.rootNodes++}}const K=[];for(N.forEach(e=>{for(const[t,o]of I)if(o.formatted===e){K.push({nodeInfo:o,formattedNode:e,depth:1,path:[t]});break}});K.length>0;){const{nodeInfo:e,formattedNode:t,depth:r,path:i}=K.pop();if(y.maxDepth=Math.max(y.maxDepth,r),r>c){console.warn(`节点 "${i.join(" -> ")}" 深度超过限制: ${r}`);continue}const a=e.children;if(f&&a.length>0)try{a.sort((e,t)=>f(e.original,t.original))}catch(e){console.warn("子节点排序失败:",e)}const d=[];for(const c of a){const a=c.original[n],l=[...i,a],h=r+1;c.depth=h;let f=c.formatted;const u={level:h,path:l,isLeaf:0===c.children.length,parent:t,childCount:c.children.length};o?f={...o(c.original,u),[s]:[]}:p&&(f={...p(c.original,u),[s]:[]}),f.__parentId=e.original[n],d.push(f),c.formatted=f,K.push({nodeInfo:c,formattedNode:f,depth:h,path:l})}t[s]=d;const l={level:r,path:i,isLeaf:0===d.length,childCount:d.length};o?(Object.assign(t,o(e.original,l)),t[s]=d):p&&(Object.assign(t,p(e.original,l)),t[s]=d)}if(f&&N.length>1)try{N.sort((e,t)=>{const o=e[n],r=t[n],s=I.get(o),i=I.get(r);return s&&i?f(s.original,i.original):0})}catch(e){console.warn("根节点排序失败:",e)}const _=performance.now(),w=process.memoryUsage?.()?.heapUsed||0;return y.buildTime=_-g,y.memoryUsed=(w-m)/1048576,N.length>0&&(N.__stats=y),N},exports.buildMinimalTree=function(e,t={}){const o={idKey:"id",parentKey:"parentId",childrenKey:"children",rootParentId:0,enableGhostNodes:!1,validateNodes:!0,maxDepth:1e3,enableCache:!1,...t};if(!Array.isArray(e)||0===e.length)return[];const n=new Map,r=[];for(const t of e){const e=t[o.idKey];o.validateNodes&&null==e?console.warn(`节点缺少ID字段 "${o.idKey}"，将被忽略:`,t):(n.has(e)&&console.warn(`发现重复ID "${e}"，后一个节点将覆盖前一个`),n.set(e,{...t,[o.childrenKey]:[]}))}const s=new Set;for(const t of e){const e=t[o.idKey],i=t[o.parentKey],a=n.get(e);if(!a)continue;if(s.has(e))continue;s.add(e);if(null==i||i===o.rootParentId)r.push(a);else{const t=n.get(i);if(t)t[o.childrenKey].push(a);else if(o.enableGhostNodes){const e={[o.idKey]:i,[o.childrenKey]:[a],__isGhost:!0};n.set(i,e),r.push(e)}else console.warn(`父节点 "${i}" 不存在，节点 "${e}" 将被作为根节点`),r.push(a)}}return r},exports.validateMinimalTree=function(e,t={}){const o=new Set,n=t.childrenKey||"children";function r(e,s){const i=e[t.idKey||"id"];if(o.has(i))return console.error(`发现循环引用，节点ID: ${i}`),!1;if(o.add(i),s>(t.maxDepth||1e3))return console.error(`树深度超过限制: ${s}`),!1;const a=e[n];if(Array.isArray(a))for(const e of a)if(!r(e,s+1))return!1;return o.delete(i),!0}try{for(const t of e)if(!r(t,1))return!1;return!0}catch(e){return console.error("树验证失败:",e),!1}};
//# sourceMappingURL=index.js.map
