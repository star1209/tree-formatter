"use strict";function e(e,t={}){const n={idKey:"id",parentKey:"parentId",childrenKey:"children",rootParentId:0,enableGhostNodes:!1,validateNodes:!0,maxDepth:1e3,enableCache:!1,...t};if(!Array.isArray(e)||0===e.length)return[];const r=new Map,o=[];for(const t of e){const e=t[n.idKey];n.validateNodes&&null==e?console.warn(`节点缺少ID字段 "${n.idKey}"，将被忽略:`,t):(r.has(e)&&console.warn(`发现重复ID "${e}"，后一个节点将覆盖前一个`),r.set(e,{...t,[n.childrenKey]:[]}))}const s=new Set;for(const t of e){const e=t[n.idKey],i=t[n.parentKey],c=r.get(e);if(!c)continue;if(s.has(e))continue;s.add(e);if(null==i||i===n.rootParentId)o.push(c);else{const t=r.get(i);if(t)t[n.childrenKey].push(c);else if(n.enableGhostNodes){const e={[n.idKey]:i,[n.childrenKey]:[c],__isGhost:!0};r.set(i,e),o.push(e)}else console.warn(`父节点 "${i}" 不存在，节点 "${e}" 将被作为根节点`),o.push(c)}}return o}function t(e,t={},n){const r=t.idKey||"id",o=t.parentKey||"parentId",s=t.childrenKey||"children",i=t.rootParentId??0,c=t.enableGhostNodes||!1,l=!1!==t.validateNodes,a=t.maxDepth||1e3,h=t.detectCycles||!1,d=t.onCycleDetected||((e,t)=>{console.warn(`发现循环引用，路径: ${t.join(" -> ")}`)}),u=t.sortChildren,f=t.formatNode,p=t.isRootNode,g=performance.now(),m=process.memoryUsage?.()?.heapUsed||0,y={totalNodes:0,rootNodes:0,maxDepth:0,buildTime:0,memoryUsed:0,cyclesDetected:0,ghostNodesCreated:0};if(!Array.isArray(e)||0===e.length)return[];const w=new Map;for(const A of e){const K=A[r],M=A[o]??null;l&&null==K?console.warn(`节点缺少ID字段 "${r}"，将被忽略:`,A):K!==M?w.set(K,{original:A,formatted:null,parentId:M,children:[],depth:0}):h&&(d(A,[K]),y.cyclesDetected++)}if(y.totalNodes=w.size,h&&w.size>0){const v=new Set,B=new Set,E=[];function P(e){if(B.has(e)){const t=E.indexOf(e);if(-1!==t){const n=E.slice(t);d(w.get(e).original,n),y.cyclesDetected++}return}if(v.has(e))return;v.add(e),B.add(e),E.push(e);const t=w.get(e);if(t&&null!==t.parentId){const n=t.parentId;w.has(n)&&e!==n&&P(n)}B.delete(e),E.pop()}w.forEach((e,t)=>{v.has(t)||P(t)})}const N=new Map;for(const[U,k]of w){const{parentId:_}=k;if(U!==_&&null!=_){if(w.get(_))N.has(_)||N.set(_,[]),N.get(_).push(k);else if(c){const L=_,G={original:{[r]:L},formatted:null,parentId:null,children:[],depth:0,isGhost:!0};w.set(L,G),N.has(L)||N.set(L,[]),N.get(L).push(k),y.ghostNodesCreated++}}}const x=[],I=[],D=new Set,S=[];w.forEach((e,t)=>{const{parentId:n,isGhost:r}=e;let o=!1;o=p?p(e.original):null==n||n===i,o&&(S.push({nodeInfo:e,id:t}),y.rootNodes++)}),S.sort((e,t)=>e.id-t.id);for(let O=S.length-1;O>=0;O--){const{nodeInfo:z,id:j}=S[O];I.push({nodeInfo:z,parentFormatted:null,depth:1,path:[j]})}for(;I.length>0;){const{nodeInfo:F,parentFormatted:R,depth:H,path:J}=I.pop();if(y.maxDepth=Math.max(y.maxDepth,H),H>a){console.warn(`节点 "${J.join(" -> ")}" 深度超过限制: ${H}`);continue}const V=F.original[r];if(D.has(V))continue;D.add(V);let q=null;R&&(q={...R},q[s]&&delete q[s]);const Q=N.get(V)||[],W={level:H,path:J,isLeaf:0===Q.length,parent:q,childCount:Q.length};let X;if(X=n?n(F.original,W):f?f(F.original,W):{...F.original},F.isGhost&&(X.__isGhost=!0),F.parentId?X.__parentId=F.parentId:X.__parentId=null,X[s]=[],F.formatted=X,R||x.push(X),u&&Q.length>0)try{Q.sort((e,t)=>u(e.original,t.original))}catch(Y){console.warn("子节点排序失败:",Y)}for(let Z=Q.length-1;Z>=0;Z--){const ee=Q[Z],te=ee.original[r],ne=[...J,te],re=H+1;I.push({nodeInfo:ee,parentFormatted:X,depth:re,path:ne})}}const $=new Map;w.forEach((e,t)=>{e.formatted&&$.set(e.formatted,t)});const C=[...x];for(;C.length>0;){const oe=C.pop(),se=$.get(oe),ie=[],ce=N.get(se)||[];for(const le of ce)le.formatted&&(ie.push(le.formatted),C.push(le.formatted));oe[s]=ie}const T=performance.now(),b=process.memoryUsage?.()?.heapUsed||0;return y.buildTime=T-g,y.memoryUsed=(b-m)/1048576,x.__stats=y,x}class n{constructor(e={}){this.plugins=[],this.cache=new Map,this.stats=[],this.config={idKey:"id",parentKey:"parentId",childrenKey:"children",rootParentId:0,enableGhostNodes:!1,validateNodes:!0,maxDepth:1e3,enableCache:!1,...e}}use(e){return this.plugins.push(e),this.plugins.sort((e,t)=>(e.priority||100)-(t.priority||100)),this}build(n){if(!n)return[];const r=performance.now(),o=this.generateCacheKey(n);if(this.config.enableCache&&this.cache.has(o)){console.log("使用缓存结果");const e=this.cache.get(o),t={totalNodes:n.length,rootNodes:e?.length||0,maxDepth:this.calculateMaxDepth(e||[]),buildTime:0,memoryUsed:0,cyclesDetected:0,ghostNodesCreated:0,cacheHit:!0};return this.stats.push(t),e}const s=this.selectStrategy(n);let i;console.log(`选择构建策略: ${s.name}`);const c=this.applyBeforeBuild(n),l=c||n;switch(s.name){case"minimal":default:i=e(l,this.config);break;case"enhanced":i=t(l,this.config);break;case"incremental":i=this.buildIncremental(l)}i=this.applyAfterBuild(i,n);const a=performance.now(),h={totalNodes:n.length,rootNodes:i.length,maxDepth:this.calculateMaxDepth(i),buildTime:a-r,memoryUsed:this.getMemoryUsage(),cyclesDetected:0,ghostNodesCreated:0};return this.stats.push(h),this.config.enableCache&&this.cache.set(o,i),i.__stats=h,i}getStats(){return this.stats}clearCache(){this.cache.clear()}reset(){this.plugins=[],this.cache.clear(),this.stats=[]}generateCacheKey(e){const t=JSON.stringify(this.config);if(!e)return`${t}:null:0`;return`${t}:${JSON.stringify(e.slice(0,Math.min(10,e.length)))}:${e.length}`}selectStrategy(e){if(e.length<1e3)return{name:"minimal",description:"最小化构建策略"};return this.plugins.length>0||this.config.enableGhostNodes||1e3!==this.config.maxDepth?{name:"enhanced",description:"增强构建策略"}:{name:"minimal",description:"最小化构建策略"}}applyBeforeBuild(e){let t=e;for(const e of this.plugins)e.onNodeCreated&&(t=t.map((t,n)=>{const r={level:0,path:[t[this.config.idKey||"id"]],isLeaf:!0,childCount:0};return e.onNodeCreated?.(t,r),t}));return t}applyAfterBuild(e,t){let n=e;for(const e of this.plugins)if(e.onTreeBuilt){const r=e.onTreeBuilt(n,{originalList:t});r&&(n=r)}return n}buildIncremental(t){const n=e(t,this.config);return this.optimizeTreeStructure(n),n}optimizeTreeStructure(e){this.flattenDeepNesting(e,this.config.maxDepth||1e3)}flattenDeepNesting(e,t){const n=this.config.childrenKey||"children";function r(r,o){if(o>=t&&r[n]?.length>0){const s={...r,[n]:[]},i=(r,o)=>{for(const c of r)o>=t?e.push(c):s[n].push(c),i(c[n]||[],o+1)};return i(r[n]||[],o),s}return r}for(let t=0;t<e.length;t++)e[t]=r(e[t],1)}calculateMaxDepth(e){const t=this.config.childrenKey||"children";let n=0;function r(e,o){n=Math.max(n,o);const s=e[t];if(Array.isArray(s))for(const e of s)r(e,o+1)}for(const t of e)r(t,1);return n}getMemoryUsage(){if("undefined"!=typeof process&&process.memoryUsage){return process.memoryUsage().heapUsed/1024/1024}return 0}}function r(e,t={}){const n={scope:"all",recursive:!0,timing:"after",...t};return{name:"sorting",priority:50,onTreeBuilt:t=>"after"===n.timing?o(t,e,n):t,onNodeLinked(t,r){if("during"===n.timing&&"root"!==n.scope&&t.children&&Array.isArray(t.children))try{t.children.sort(e)}catch(e){console.warn("节点排序失败:",e)}}}}function o(e,t,n){if(!e||!Array.isArray(e)||0===e.length)return e;let r=[...e];try{if("all"!==n.scope&&"root"!==n.scope||r.sort(t),n.recursive&&("all"===n.scope||"children"===n.scope))for(const e of r)e.children&&Array.isArray(e.children)&&e.children.length>0&&(e.children=o(e.children,t,n))}catch(e){console.error("树排序失败:",e)}return r}exports.AUTHOR="Tree Formatter Library",exports.DESCRIPTION="高性能、模块化的树形结构构建库",exports.PluginManager=class{constructor(){this.plugins=new Map}register(e){this.plugins.has(e.name)&&console.warn(`插件 "${e.name}" 已存在，将被覆盖`),this.plugins.set(e.name,e)}unregister(e){return this.plugins.delete(e)}getPlugin(e){return this.plugins.get(e)}getAllPlugins(){return Array.from(this.plugins.values()).sort((e,t)=>(e.priority||100)-(t.priority||100))}applyNodeCreated(e,t){let n=e;for(const e of this.getAllPlugins())e.onNodeCreated&&e.onNodeCreated(n,t);return n}applyNodeLinked(e,t,n){let r=!0;for(const o of this.getAllPlugins())if(o.onNodeLinked){if(!1===o.onNodeLinked(e,t,n)){r=!1;break}}return r}applyTreeBuilt(e,t){let n=e;for(const e of this.getAllPlugins())if(e.onTreeBuilt){const r=e.onTreeBuilt(n,t);r&&(n=r)}return n}clear(){this.plugins.clear()}get count(){return this.plugins.size}},exports.SmartTreeBuilder=n,exports.VERSION="1.0.0",exports.buildEnhancedTree=t,exports.buildMinimalTree=e,exports.createAdvancedTree=function(e,n={},r){return t(e,n,r)},exports.createCycleDetectionPlugin=function(e={}){const t={throwOnCycle:!1,fixStrategy:"remove",...e},n=new Set,r=new Set,o=[],s=(e,t)=>{const n=function e(n){return n.filter(n=>!t.has(n.id)&&(n.children&&n.children.length>0&&(n.children=e(n.children)),!0))}(e);e.length=0,e.push(...n)},i=(e,t,n)=>{!function e(r){for(let o=0;o<r.length;o++){const s=r[o];if(s.id===t&&s.children){const e=s.children.findIndex(e=>e.id===n);if(-1!==e)return s.children.splice(e,1),console.log(`已断开链接: ${t} -> ${n}`),!0}if(s.children&&s.children.length>0&&e(s.children))return!0}return!1}(e)};return{name:"cycle-detection",priority:10,onNodeLinked(e,n,s){const i=e.id,c=n.id;if(i===c){if(console.error(`发现自循环引用: ${i} -> ${c}`),t.throwOnCycle)throw new Error(`循环引用: ${i} -> ${c}`);return o.push([i,c]),"remove"===t.fixStrategy}if(r.add(i),r.has(c)){const e=Array.from(r),n=e.indexOf(c),s=e.slice(n);if(s.push(c),console.error(`发现循环引用: ${s.join(" -> ")}`),o.push(s),t.throwOnCycle)throw new Error(`循环引用: ${s.join(" -> ")}`);return r.delete(i),"remove"===t.fixStrategy}return r.delete(i),!0},onTreeBuilt(e){o.length>0&&(console.warn(`检测到 ${o.length} 个循环引用`),"remove"===t.fixStrategy?(e=>{const t=new Set;o.forEach(e=>{const n=e[e.length-1];t.add(n)}),s(e,t)})(e):"break"===t.fixStrategy&&(e=>{o.forEach(t=>{const n=t[t.length-2],r=t[t.length-1];i(e,n,r)})})(e)),n.clear(),r.clear()}}},exports.createMultiLevelSorting=function(e){return r(function(e){return(t,n)=>{for(const r of e){const e=t[r.key],o=n[r.key];let s=0;if("number"===r.type){s=(Number(e)||0)-(Number(o)||0)}else if("date"===r.type){s=(e?new Date(e).getTime():0)-(o?new Date(o).getTime():0)}else{const t=String(e||""),n=String(o||"");s=t.localeCompare(n)}if("desc"===r.order&&(s=-s),0!==s)return s}return 0}}(e),{scope:"all",recursive:!0,timing:"after"})},exports.createPluginTreeBuilder=function(e=[],t={}){const r=new n(t);return e.forEach(e=>{r.use(e)}),r},exports.createSortingPlugin=r,exports.createTopologicalDetector=function(){const e=new Map,t=new Map;return{name:"topological-detector",priority:5,onNodeLinked(n,r){const o=n.id,s=r.id;e.has(o)||e.set(o,new Set),t.has(s)||t.set(s,0),t.has(o)||t.set(o,0),e.get(o).add(s),t.set(s,(t.get(s)||0)+1)},onTreeBuilt(){const n=[],r=[];for(t.forEach((e,t)=>{0===e&&n.push(t)});n.length>0;){const o=n.shift();r.push(o);const s=e.get(o);s&&s.forEach(e=>{const r=(t.get(e)||1)-1;t.set(e,r),0===r&&n.push(e)})}if(r.length!==e.size){console.error(`检测到循环引用，拓扑排序失败，共有 ${e.size} 个节点，排序了 ${r.length} 个`);const n=new Set;t.forEach((e,t)=>{e>0&&n.add(t)}),console.error(`环中的节点: ${Array.from(n).join(", ")}`)}e.clear(),t.clear()}}},exports.createTree=function(n,r={}){return n.length<1e3?e(n,r):t(n,r)},exports.validateMinimalTree=function(e,t={}){const n=new Set,r=t.childrenKey||"children";function o(e,s){const i=e[t.idKey||"id"];if(n.has(i))return console.error(`发现循环引用，节点ID: ${i}`),!1;if(n.add(i),s>(t.maxDepth||1e3))return console.error(`树深度超过限制: ${s}`),!1;const c=e[r];if(Array.isArray(c))for(const e of c)if(!o(e,s+1))return!1;return n.delete(i),!0}try{for(const t of e)if(!o(t,1))return!1;return!0}catch(e){return console.error("树验证失败:",e),!1}};
//# sourceMappingURL=index.js.map
