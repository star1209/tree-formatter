function e(e,t={}){const n={idKey:"id",parentKey:"parentId",childrenKey:"children",rootParentId:0,enableGhostNodes:!1,validateNodes:!0,maxDepth:1e3,enableCache:!1,...t};if(!Array.isArray(e)||0===e.length)return[];const o=new Map,r=[];for(const t of e){const e=t[n.idKey];n.validateNodes&&null==e?console.warn(`节点缺少ID字段 "${n.idKey}"，将被忽略:`,t):(o.has(e)&&console.warn(`发现重复ID "${e}"，后一个节点将覆盖前一个`),o.set(e,{...t,[n.childrenKey]:[]}))}const s=new Set;for(const t of e){const e=t[n.idKey],a=t[n.parentKey],d=o.get(e);if(!d)continue;if(s.has(e))continue;s.add(e);if(null==a||a===n.rootParentId)r.push(d);else{const t=o.get(a);if(t)t[n.childrenKey].push(d);else if(n.enableGhostNodes){const e={[n.idKey]:a,[n.childrenKey]:[d],__isGhost:!0};o.set(a,e),r.push(e)}else console.warn(`父节点 "${a}" 不存在，节点 "${e}" 将被作为根节点`),r.push(d)}}return function e(t){for(const o of t)Array.isArray(o[n.childrenKey])&&0===o[n.childrenKey].length?delete o[n.childrenKey]:e(o[n.childrenKey])}(r),r}function t(e,t={}){const n=new Set,o=t.childrenKey||"children";function r(e,s){const a=e[t.idKey||"id"];if(n.has(a))return console.error(`发现循环引用，节点ID: ${a}`),!1;if(n.add(a),s>(t.maxDepth||1e3))return console.error(`树深度超过限制: ${s}`),!1;const d=e[o];if(Array.isArray(d))for(const e of d)if(!r(e,s+1))return!1;return n.delete(a),!0}try{for(const t of e)if(!r(t,1))return!1;return!0}catch(e){return console.error("树验证失败:",e),!1}}function n(e,t={},n){const o=t.idKey||"id",r=t.parentKey||"parentId",s=t.childrenKey||"children",a=t.rootParentId??0,d=t.enableGhostNodes||!1,i=!1!==t.validateNodes,l=t.maxDepth||1e3,c=t.detectCycles||!1,h=t.onCycleDetected||((e,t)=>{console.warn(`发现循环引用，路径: ${t.join(" -> ")}`)}),f=t.sortChildren,p=t.formatNode,u=t.isRootNode,y=performance.now(),g=process.memoryUsage?.()?.heapUsed||0,m={totalNodes:0,rootNodes:0,maxDepth:0,buildTime:0,memoryUsed:0,cyclesDetected:0,ghostNodesCreated:0};if(!Array.isArray(e)||0===e.length)return[];const I=new Map;for(const C of e){const b=C[o],U=C[r]??null;i&&null==b?console.warn(`节点缺少ID字段 "${o}"，将被忽略:`,C):b!==U?I.set(b,{original:C,formatted:null,parentId:U,children:[],depth:0}):c&&(h(C,[b]),m.cyclesDetected++)}if(m.totalNodes=I.size,c&&I.size>0){const M=new Set,S=new Set,v=[];function E(e){if(S.has(e)){const t=v.indexOf(e);if(-1!==t){const n=v.slice(t);h(I.get(e).original,n),m.cyclesDetected++}return}if(M.has(e))return;M.add(e),S.add(e),v.push(e);const t=I.get(e);if(t&&null!==t.parentId){const n=t.parentId;I.has(n)&&e!==n&&E(n)}S.delete(e),v.pop()}I.forEach((e,t)=>{M.has(t)||E(t)})}const K=new Map;for(const[F,P]of I){const{parentId:j}=P;if(F!==j&&null!=j){if(I.get(j))K.has(j)||K.set(j,[]),K.get(j).push(P);else if(d){const z=j,T={original:{[o]:z},formatted:null,parentId:null,children:[],depth:0,isGhost:!0};I.set(z,T),K.has(z)||K.set(z,[]),K.get(z).push(P),m.ghostNodesCreated++}}}const w=[],D=[],N=new Set,A=[];I.forEach((e,t)=>{const{parentId:n,isGhost:o}=e;let r=!1;r=u?u(e.original):null==n||n===a,r&&(A.push({nodeInfo:e,id:t}),m.rootNodes++)}),A.sort((e,t)=>e.id-t.id);for(let L=A.length-1;L>=0;L--){const{nodeInfo:O,id:R}=A[L];D.push({nodeInfo:O,parentFormatted:null,depth:1,path:[R]})}for(;D.length>0;){const{nodeInfo:k,parentFormatted:q,depth:B,path:H}=D.pop();if(m.maxDepth=Math.max(m.maxDepth,B),B>l){console.warn(`节点 "${H.join(" -> ")}" 深度超过限制: ${B}`);continue}const J=k.original[o];if(N.has(J))continue;N.add(J);let Q=null;q&&(Q={...q},Q[s]&&delete Q[s]);const V=K.get(J)||[],W={level:B,path:H,isLeaf:0===V.length,parent:Q,childCount:V.length};let X;if(X=n?n(k.original,W):p?p(k.original,W):{...k.original},k.isGhost&&(X.__isGhost=!0),k.parentId?X.__parentId=k.parentId:X.__parentId=null,X[s]=[],k.formatted=X,q||w.push(X),f&&V.length>0)try{V.sort((e,t)=>f(e.original,t.original))}catch(Y){console.warn("子节点排序失败:",Y)}for(let Z=V.length-1;Z>=0;Z--){const ee=V[Z],te=ee.original[o],ne=[...H,te],oe=B+1;D.push({nodeInfo:ee,parentFormatted:X,depth:oe,path:ne})}}const $=new Map;I.forEach((e,t)=>{e.formatted&&$.set(e.formatted,t)});const _=[...w];for(;_.length>0;){const re=_.pop(),se=$.get(re),ae=[],de=K.get(se)||[];for(const ie of de)ie.formatted&&(ae.push(ie.formatted),_.push(ie.formatted));re[s]=ae}const x=performance.now(),G=process.memoryUsage?.()?.heapUsed||0;return m.buildTime=x-y,m.memoryUsed=(G-g)/1048576,w.__stats=m,function e(t){for(const n of t)Array.isArray(n[s])&&0===n[s].length?delete n[s]:e(n[s]||[])}(w),w}export{n as buildEnhancedTree,e as buildMinimalTree,t as validateMinimalTree};
//# sourceMappingURL=index.esm.js.map
