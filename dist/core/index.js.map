{"version":3,"file":"index.js","sources":["../../src/core/enhanced.ts","../../src/core/minimal.ts"],"sourcesContent":["import { EnhancedTreeConfig, NodeContext, BuildStats } from './types';\n\n/**\n * 增强树形构建器\n * 支持循环引用检测、节点排序、格式化等高级功能\n */\nexport function buildEnhancedTree<T = any, R = T>(\n  list: T[],\n  options: EnhancedTreeConfig<T> = {},\n  formatCallback?: (node: T, context: NodeContext) => R\n): R[] {\n  // 提取配置，分别处理每个属性\n  const idKey = options.idKey || 'id';\n  const parentKey = options.parentKey || 'parentId';\n  const childrenKey = options.childrenKey || 'children';\n  const rootParentId = options.rootParentId ?? 0;\n  const enableGhostNodes = options.enableGhostNodes || false;\n  const validateNodes = options.validateNodes !== false; // 默认为true\n  const maxDepth = options.maxDepth || 1000;\n  const detectCycles = options.detectCycles || false;\n  const onCycleDetected = options.onCycleDetected || ((node: T, path: (string | number)[]) => {\n    console.warn(`发现循环引用，路径: ${path.join(' -> ')}`);\n  });\n  const sortChildren = options.sortChildren;\n  const formatNode = options.formatNode;\n  const isRootNode = options.isRootNode;\n\n  // 性能监控\n  const startTime = performance.now();\n  const startMemory = process.memoryUsage?.()?.heapUsed || 0;\n  const stats: BuildStats = {\n    totalNodes: 0,\n    rootNodes: 0,\n    maxDepth: 0,\n    buildTime: 0,\n    memoryUsed: 0,\n    cyclesDetected: 0,\n    ghostNodesCreated: 0\n  };\n\n  // 空列表检查\n  if (!Array.isArray(list) || list.length === 0) {\n    return [];\n  }\n\n  // 节点映射表\n  const nodeMap = new Map<string | number, {\n    original: T;\n    formatted: any;\n    parentId: string | number | null;\n    children: any[];\n    depth: number;\n    isGhost?: boolean;\n  }>();\n\n  // 根节点列表\n  const roots: any[] = [];\n\n  // 第一步：收集所有节点\n  for (const item of list) {\n    const id = (item as any)[idKey];\n    const parentId = (item as any)[parentKey] ?? null;\n\n    // 验证节点\n    if (validateNodes && (id === undefined || id === null)) {\n      console.warn(`节点缺少ID字段 \"${idKey}\"，将被忽略:`, item);\n      continue;\n    }\n\n    // 检查自引用\n    if (id === parentId) {\n      if (detectCycles) {\n        onCycleDetected(item, [id]);\n        stats.cyclesDetected++;\n      }\n      continue;\n    }\n\n    // 创建格式化节点（如果需要）\n    const initialContext: NodeContext = {\n      level: 0,\n      path: [id],\n      isLeaf: true,\n      childCount: 0\n    };\n\n    let formattedNode: any;\n    if (formatCallback) {\n      formattedNode = formatCallback(item, initialContext);\n      formattedNode[childrenKey] = [];\n    } else if (formatNode) {\n      formattedNode = formatNode(item, initialContext);\n      formattedNode[childrenKey] = [];\n    } else {\n      formattedNode = {\n        ...item,\n        [childrenKey]: []\n      };\n    }\n\n    nodeMap.set(id, {\n      original: item,\n      formatted: formattedNode,\n      parentId,\n      children: [],\n      depth: 0\n    });\n  }\n\n  stats.totalNodes = nodeMap.size;\n\n  // 第二步：检测循环引用（如果需要）\n  if (detectCycles && nodeMap.size > 0) {\n    const cycles = detectCyclesInMap(nodeMap, idKey);\n    \n    cycles.forEach((cycle: (string | number)[]) => {\n      stats.cyclesDetected++;\n      const cycleNode = nodeMap.get(cycle[0]);\n      if (cycleNode) {\n        onCycleDetected(cycleNode.original, cycle);\n        nodeMap.delete(cycle[0]); // 移除环中的节点\n      }\n    });\n  }\n\n  // 第三步：建立父子关系\n  for (const [id, nodeInfo] of nodeMap) {\n    // 跳过幽灵节点，因为它们已经作为根节点添加了\n    if (nodeInfo.isGhost) {\n      continue;\n    }\n    const { parentId } = nodeInfo;\n\n    // 判断是否为根节点\n    const isRoot = parentId === null || \n              parentId === undefined || \n              parentId === rootParentId;\n\n    if (isRoot) {\n      roots.push(nodeInfo.formatted);\n      nodeInfo.depth = 1;\n      stats.rootNodes++;\n    } else {\n      const parentInfo = nodeMap.get(parentId!);\n      if (parentInfo) {\n        // 父节点存在，正常挂载\n        parentInfo.children.push(nodeInfo);\n        nodeInfo.formatted.__parentId = parentId;\n      } else {\n        // 父节点不存在\n        if (enableGhostNodes) {\n          // 检查是否已经存在这个幽灵节点（在 nodeMap 或 roots 中）\n          const existingGhostNode = nodeMap.get(parentId!);\n          if (existingGhostNode) {\n            // 幽灵节点已存在，直接将当前节点添加到其子节点\n            existingGhostNode.children.push(nodeInfo);\n            nodeInfo.formatted.__parentId = parentId;\n            nodeInfo.depth = existingGhostNode.depth + 1;\n          } else {\n            // 创建新的幽灵节点\n            const ghostNode = {\n              [idKey]: parentId,\n              [childrenKey]: [nodeInfo.formatted],\n              __isGhost: true,\n              __parentId: null\n            };\n            \n            const ghostInfo = {\n              original: { [idKey]: parentId } as T,\n              formatted: ghostNode,\n              parentId: null,\n              children: [nodeInfo],\n              depth: 1,\n              isGhost: true\n            };\n            \n            nodeMap.set(parentId!, ghostInfo);\n            roots.push(ghostNode);\n            nodeInfo.formatted.__parentId = parentId;\n            nodeInfo.depth = 2;\n            stats.ghostNodesCreated++;\n            stats.rootNodes++;\n          }\n          /* // 创建幽灵节点\n          const ghostNode = {\n            [idKey]: parentId,\n            [childrenKey]: [nodeInfo.formatted],\n            __isGhost: true,\n            __parentId: null\n          };\n          \n          const ghostInfo = {\n            original: { [idKey]: parentId } as T,\n            formatted: ghostNode,\n            parentId: null,\n            children: [nodeInfo],\n            depth: 1\n          };\n          \n          nodeMap.set(parentId!, ghostInfo);\n          roots.push(ghostNode); // 幽灵节点作为根节点\n          nodeInfo.formatted.__parentId = parentId;\n          nodeInfo.depth = 2;\n          stats.ghostNodesCreated++;\n          stats.rootNodes++; */\n        } else {\n          // 不启用幽灵节点，将当前节点作为根节点\n          roots.push(nodeInfo.formatted);\n          nodeInfo.depth = 1;\n          stats.rootNodes++;\n        }\n      }\n    }\n  }\n\n  // 第四步：深度优先计算层级和路径\n  const stack: Array<{\n    nodeInfo: any;\n    formattedNode: any;\n    depth: number;\n    path: (string | number)[];\n  }> = [];\n\n  // 初始化栈\n  roots.forEach(rootNode => {\n    const rootId = rootNode[idKey];\n    const nodeInfo = nodeMap.get(rootId);\n    if (nodeInfo) {\n      stack.push({\n        nodeInfo,\n        formattedNode: rootNode,\n        depth: 1,\n        path: [rootId]\n      });\n    }\n  });\n\n  while (stack.length > 0) {\n    const { nodeInfo, formattedNode, depth, path } = stack.pop()!;\n    \n    // 更新最大深度\n    stats.maxDepth = Math.max(stats.maxDepth, depth);\n    \n    // 检查深度限制\n    if (depth > maxDepth) {\n      console.warn(`节点 \"${path.join(' -> ')}\" 深度超过限制: ${depth}`);\n      continue;\n    }\n\n    // 处理子节点\n    const childrenInfos = nodeInfo.children;\n    \n    // 子节点排序\n    if (sortChildren && childrenInfos.length > 0) {\n      try {\n        childrenInfos.sort((a: any, b: any) => \n          sortChildren(a.original, b.original)\n        );\n      } catch (error) {\n        console.warn('子节点排序失败:', error);\n      }\n    }\n\n    // 构建子节点\n    const children: any[] = [];\n    for (const childInfo of childrenInfos) {\n      const childId = childInfo.original[idKey];\n      const childPath = [...path, childId];\n      const childDepth = depth + 1;\n      \n      // 更新子节点深度\n      childInfo.depth = childDepth;\n      \n      // 创建或获取格式化节点\n      let childFormatted = childInfo.formatted;\n      \n      // 计算子节点上下文\n      const childContext: NodeContext = {\n        level: childDepth,\n        path: childPath,\n        isLeaf: childInfo.children.length === 0,\n        parent: formattedNode,\n        childCount: childInfo.children.length\n      };\n      \n      // 应用格式化回调\n      if (formatCallback) {\n        childFormatted = {\n          ...formatCallback(childInfo.original, childContext),\n          [childrenKey]: []\n        };\n      } else if (formatNode) {\n        childFormatted = {\n          ...formatNode(childInfo.original, childContext),\n          [childrenKey]: []\n        };\n      }\n      \n      // 设置父ID引用\n      childFormatted.__parentId = nodeInfo.original[idKey];\n      \n      children.push(childFormatted);\n      childInfo.formatted = childFormatted;\n      \n      // 继续处理子节点的子节点\n      stack.push({\n        nodeInfo: childInfo,\n        formattedNode: childFormatted,\n        depth: childDepth,\n        path: childPath\n      });\n    }\n    \n    // 更新当前节点的子节点列表\n    formattedNode[childrenKey] = children;\n    \n    // 更新当前节点的上下文信息\n    const currentContext: NodeContext = {\n      level: depth,\n      path,\n      isLeaf: children.length === 0,\n      childCount: children.length\n    };\n    \n    // 重新格式化当前节点（如果需要）\n    if (formatCallback) {\n      Object.assign(formattedNode, formatCallback(nodeInfo.original, currentContext));\n      formattedNode[childrenKey] = children; // 保持子节点引用\n    } else if (formatNode) {\n      Object.assign(formattedNode, formatNode(nodeInfo.original, currentContext));\n      formattedNode[childrenKey] = children;\n    }\n  }\n\n  // 第五步：根节点排序\n  if (sortChildren && roots.length > 1) {\n    try {\n      roots.sort((a, b) => {\n        const aId = a[idKey];\n        const bId = b[idKey];\n        const aInfo = nodeMap.get(aId);\n        const bInfo = nodeMap.get(bId);\n        \n        if (aInfo && bInfo) {\n          return sortChildren(aInfo.original, bInfo.original);\n        }\n        return 0;\n      });\n    } catch (error) {\n      console.warn('根节点排序失败:', error);\n    }\n  }\n\n  // 计算性能统计\n  const endTime = performance.now();\n  const endMemory = process.memoryUsage?.()?.heapUsed || 0;\n  \n  stats.buildTime = endTime - startTime;\n  stats.memoryUsed = (endMemory - startMemory) / (1024 * 1024); // 转换为MB\n\n  // 添加统计信息到根节点\n  if (roots.length > 0) {\n    (roots as any).__stats = stats;\n  }\n\n  return roots;\n}\n\n/**\n * 循环引用检测函数\n */\nfunction detectCyclesInMap(\n  nodeMap: Map<string | number, any>,\n  idKey: string\n): (string | number)[][] {\n  const adjacency = new Map<string | number, Set<string | number>>();\n  const inDegree = new Map<string | number, number>();\n  \n  // 初始化图\n  nodeMap.forEach((nodeInfo, id) => {\n    adjacency.set(id, new Set());\n    inDegree.set(id, 0);\n  });\n  \n  // 构建边\n  nodeMap.forEach((nodeInfo, id) => {\n    const parentId = nodeInfo.parentId;\n    if (parentId !== null && nodeMap.has(parentId) && id !== parentId) {\n      adjacency.get(parentId)!.add(id);\n      inDegree.set(id, (inDegree.get(id) || 0) + 1);\n    }\n  });\n  \n  // Kahn算法检测环\n  const queue: (string | number)[] = [];\n  const cycles: (string | number)[][] = [];\n  \n  // 入度为0的节点入队\n  inDegree.forEach((degree, id) => {\n    if (degree === 0) {\n      queue.push(id);\n    }\n  });\n  \n  // 处理队列\n  while (queue.length > 0) {\n    const current = queue.shift()!;\n    \n    const neighbors = adjacency.get(current);\n    if (neighbors) {\n      neighbors.forEach(neighbor => {\n        const newDegree = (inDegree.get(neighbor) || 1) - 1;\n        inDegree.set(neighbor, newDegree);\n        \n        if (newDegree === 0) {\n          queue.push(neighbor);\n        }\n      });\n    }\n  }\n  \n  // 找出环中的节点\n  const visited = new Set<string | number>();\n  \n  inDegree.forEach((degree, id) => {\n    if (degree > 0 && !visited.has(id)) {\n      const cycle: (string | number)[] = [];\n      let current = id;\n      \n      while (!visited.has(current)) {\n        visited.add(current);\n        cycle.push(current);\n        \n        // 找到下一个在环中的节点\n        const neighbors = Array.from(adjacency.get(current) || []);\n        for (const neighbor of neighbors) {\n          if (inDegree.get(neighbor)! > 0 && !visited.has(neighbor)) {\n            current = neighbor;\n            break;\n          }\n        }\n      }\n      \n      if (cycle.length > 0) {\n        cycles.push(cycle);\n      }\n    }\n  });\n  \n  return cycles;\n}","import { TreeBuilderConfig } from './types';\n\n/**\n * 最小化树形构建器（对标 row-to-tree）\n * 时间复杂度: O(n)，空间复杂度: O(n)\n */\nexport function buildMinimalTree<T = any>(\n  list: T[],\n  options: TreeBuilderConfig<T> = {}\n): any[] {\n  // 合并配置\n  const config: Required<TreeBuilderConfig> = {\n    idKey: 'id',\n    parentKey: 'parentId',\n    childrenKey: 'children',\n    rootParentId: 0,\n    enableGhostNodes: false,\n    validateNodes: true,\n    maxDepth: 1000,\n    enableCache: false,\n    ...options\n  };\n\n  // 空列表检查\n  if (!Array.isArray(list) || list.length === 0) {\n    return [];\n  }\n\n  const map = new Map<string | number, any>();\n  const roots: any[] = [];\n\n  // 第一遍：创建所有节点\n  for (const item of list) {\n    const id = (item as any)[config.idKey];\n    \n    // 验证节点ID\n    if (config.validateNodes && (id === undefined || id === null)) {\n      console.warn(`节点缺少ID字段 \"${config.idKey}\"，将被忽略:`, item);\n      continue;\n    }\n\n    // 检查重复ID\n    if (map.has(id)) {\n      console.warn(`发现重复ID \"${id}\"，后一个节点将覆盖前一个`);\n    }\n\n    map.set(id, {\n      ...item,\n      [config.childrenKey]: []\n    });\n  }\n\n  // 第二遍：建立父子关系\n  const processedIds = new Set<string | number>();\n  for (const item of list) {\n    const id = (item as any)[config.idKey];\n    const parentId = (item as any)[config.parentKey];\n    \n    const node = map.get(id);\n    if (!node) continue;\n\n    // 如果这个ID已经处理过，跳过（避免重复ID被多次处理）\n    if (processedIds.has(id)) {\n      continue;\n    }\n    processedIds.add(id);\n\n    // 判断是否为根节点\n    const isRoot = parentId === null || \n                  parentId === undefined || \n                  parentId === config.rootParentId;\n\n    if (isRoot) {\n      roots.push(node);\n    } else {\n      const parent = map.get(parentId);\n      \n      if (parent) {\n        // 正常父子关系\n        parent[config.childrenKey].push(node);\n      } else if (config.enableGhostNodes) {\n        // 创建幽灵节点\n        const ghostNode = { \n          [config.idKey]: parentId, \n          [config.childrenKey]: [node],\n          __isGhost: true \n        };\n        map.set(parentId, ghostNode);\n        roots.push(ghostNode);\n      } else {\n        // 父节点不存在，作为根节点\n        console.warn(`父节点 \"${parentId}\" 不存在，节点 \"${id}\" 将被作为根节点`);\n        roots.push(node);\n      }\n    }\n  }\n\n  return roots;\n}\n\n/**\n * 验证最小树的有效性\n */\nexport function validateMinimalTree(tree: any[], config: TreeBuilderConfig = {}): boolean {\n  const visited = new Set<string | number>();\n  const childrenKey = config.childrenKey || 'children';\n  \n  function validateNode(node: any, depth: number): boolean {\n    const id = node[config.idKey || 'id'];\n    \n    // 检查循环引用\n    if (visited.has(id)) {\n      console.error(`发现循环引用，节点ID: ${id}`);\n      return false;\n    }\n    \n    visited.add(id);\n    \n    // 检查深度限制\n    if (depth > (config.maxDepth || 1000)) {\n      console.error(`树深度超过限制: ${depth}`);\n      return false;\n    }\n    \n    // 递归检查子节点\n    const children = node[childrenKey];\n    if (Array.isArray(children)) {\n      for (const child of children) {\n        if (!validateNode(child, depth + 1)) {\n          return false;\n        }\n      }\n    }\n    \n    visited.delete(id);\n    return true;\n  }\n  \n  try {\n    for (const node of tree) {\n      if (!validateNode(node, 1)) {\n        return false;\n      }\n    }\n    return true;\n  } catch (error) {\n    console.error('树验证失败:', error);\n    return false;\n  }\n}"],"names":["list","options","formatCallback","idKey","parentKey","childrenKey","rootParentId","enableGhostNodes","validateNodes","maxDepth","detectCycles","onCycleDetected","node","path","console","warn","join","sortChildren","formatNode","isRootNode","startTime","performance","now","startMemory","process","memoryUsage","heapUsed","stats","totalNodes","rootNodes","buildTime","memoryUsed","cyclesDetected","ghostNodesCreated","Array","isArray","length","nodeMap","Map","roots","item","id","parentId","initialContext","level","isLeaf","childCount","formattedNode","set","original","formatted","children","depth","size","cycles","adjacency","inDegree","forEach","nodeInfo","Set","has","get","add","queue","degree","push","current","shift","neighbors","neighbor","newDegree","visited","cycle","from","detectCyclesInMap","cycleNode","delete","isGhost","parentInfo","__parentId","existingGhostNode","ghostNode","__isGhost","ghostInfo","stack","rootNode","rootId","pop","Math","max","childrenInfos","sort","a","b","error","childInfo","childId","childPath","childDepth","childFormatted","childContext","parent","currentContext","Object","assign","aId","bId","aInfo","bInfo","endTime","endMemory","__stats","config","enableCache","map","processedIds","tree","validateNode","child"],"mappings":"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"}