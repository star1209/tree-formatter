"use strict";function e(e,t={}){const n={idKey:"id",parentKey:"parentId",childrenKey:"children",rootParentId:0,enableGhostNodes:!1,validateNodes:!0,maxDepth:1e3,enableCache:!1,...t};if(!Array.isArray(e)||0===e.length)return[];const s=new Map,i=[];for(const t of e){const e=t[n.idKey];n.validateNodes&&null==e?console.warn(`节点缺少ID字段 "${n.idKey}"，将被忽略:`,t):(s.has(e)&&console.warn(`发现重复ID "${e}"，后一个节点将覆盖前一个`),s.set(e,{...t,[n.childrenKey]:[]}))}const o=new Set;for(const t of e){const e=t[n.idKey],r=t[n.parentKey],a=s.get(e);if(!a)continue;if(o.has(e))continue;o.add(e);if(null==r||r===n.rootParentId)i.push(a);else{const t=s.get(r);if(t)t[n.childrenKey].push(a);else if(n.enableGhostNodes){const e={[n.idKey]:r,[n.childrenKey]:[a],__isGhost:!0};s.set(r,e),i.push(e)}else console.warn(`父节点 "${r}" 不存在，节点 "${e}" 将被作为根节点`),i.push(a)}}return i}function t(e,t={},n){const s=t.idKey||"id",i=t.parentKey||"parentId",o=t.childrenKey||"children",r=t.rootParentId??0,a=t.enableGhostNodes||!1,c=!1!==t.validateNodes,h=t.maxDepth||1e3,d=t.detectCycles||!1,l=t.onCycleDetected||((e,t)=>{console.warn(`发现循环引用，路径: ${t.join(" -> ")}`)}),p=t.sortChildren,f=t.formatNode,u=t.isRootNode;if(performance.now(),process.memoryUsage?.(),!Array.isArray(e)||0===e.length)return[];const g=new Map,y=[];for(const t of e){const e=t[s],r=t[i]??null;if(c&&null==e){console.warn(`节点缺少ID字段 "${s}"，将被忽略:`,t);continue}if(e===r){d&&l(t,[e]);continue}const a={level:0,path:[e],isLeaf:!0,childCount:0};let h;n?(h=n(t,a),h[o]=[]):f?(h=f(t,a),h[o]=[]):h={...t,[o]:[]},g.set(e,{original:t,formatted:h,parentId:r,children:[],depth:0})}if(g.size,d&&g.size>0){const e=new Set;for(const[t,n]of g)n.parentId===t&&(l(n.original,[t]),e.add(t));e.forEach(e=>{g.delete(e)})}for(const[e,t]of g){if(t.isGhost)continue;const{parentId:e}=t;if(u?u(t.original):null==e||e===r)y.push(t.formatted),t.depth=1;else{const n=g.get(e);if(n)n.children.push(t),t.formatted.__parentId=e;else if(a){const n=g.get(e);if(n)n.children.push(t),t.formatted.__parentId=e,t.depth=n.depth+1;else{const n={[s]:e,[o]:[t.formatted],__isGhost:!0,__parentId:null},i={original:{[s]:e},formatted:n,parentId:null,children:[t],depth:1,isGhost:!0};g.set(e,i),y.push(n),t.formatted.__parentId=e,t.depth=2}}else y.push(t.formatted),t.depth=1}}const m=[];for(y.forEach(e=>{for(const[t,n]of g)if(n.formatted===e){m.push({nodeInfo:n,formattedNode:e,depth:1,path:[t]});break}});m.length>0;){const{nodeInfo:e,formattedNode:t,depth:i,path:r}=m.pop();if(i>h){console.warn(`节点 "${r.join(" -> ")}" 深度超过限制: ${i}`);continue}const a=e.children;if(p&&a.length>0)try{a.sort((e,t)=>p(e.original,t.original))}catch(e){console.warn("子节点排序失败:",e)}const c=[];for(const h of a){const a=h.original[s],d=[...r,a],l=i+1;h.depth=l;let p=h.formatted;const u={level:l,path:d,isLeaf:0===h.children.length,parent:t,childCount:h.children.length};n?p={...n(h.original,u),[o]:[]}:f&&(p={...f(h.original,u),[o]:[]}),p.__parentId=e.original[s],c.push(p),h.formatted=p,m.push({nodeInfo:h,formattedNode:p,depth:l,path:d})}t[o]=c;const d={level:i,path:r,isLeaf:0===c.length,childCount:c.length};n?(Object.assign(t,n(e.original,d)),t[o]=c):f&&(Object.assign(t,f(e.original,d)),t[o]=c)}if(p&&y.length>1)try{y.sort((e,t)=>{const n=e[s],i=t[s],o=g.get(n),r=g.get(i);return o&&r?p(o.original,r.original):0})}catch(e){console.warn("根节点排序失败:",e)}return performance.now(),process.memoryUsage?.(),y}class n{constructor(){this.name="minimal",this.description="最小化构建策略（对标 row-to-tree）"}build(t,n){return e(t,n)}}class s{constructor(){this.name="enhanced",this.description="增强构建策略（支持循环检测、排序等）"}build(e,n){return t(e,n)}}class i{constructor(){this.name="recursive",this.description="递归构建策略（适合深度嵌套）"}build(e,t){const n=t.idKey||"id",s=t.parentKey||"parentId",i=t.childrenKey||"children",o=t.rootParentId??0,r=new Map;e.forEach(e=>{const t=e[n];null!=t&&r.set(t,{...e,[i]:[]})});const a=(t=o)=>{const c=[];return e.forEach(e=>{const o=e[n];if(e[s]===t){const e=r.get(o);if(e){const t=a(o);e[i]=t,c.push(e)}}}),c};return a()}}exports.EnhancedStrategy=s,exports.IncrementalTreeBuilder=class{constructor(e={}){this.tree=[],this.nodeMap=new Map,this.config={idKey:"id",parentKey:"parentId",childrenKey:"children",rootParentId:0,enableGhostNodes:!1,validateNodes:!0,maxDepth:1e3,enableCache:!1,...e}}addNode(e){const t=e[this.config.idKey],n=e[this.config.parentKey]??null;if(this.nodeMap.has(t))return console.warn(`节点 ${t} 已存在，将更新该节点`),this.updateNode(t,e);const s={...e,[this.config.childrenKey]:[]};this.nodeMap.set(t,s);if(null==n||n===this.config.rootParentId||!this.nodeMap.has(n))this.tree.push(s);else{const e=this.nodeMap.get(n);if(e)e[this.config.childrenKey].push(s);else if(this.config.enableGhostNodes){const e={[this.config.idKey]:n,[this.config.childrenKey]:[s],__isGhost:!0};this.nodeMap.set(n,e),this.tree.push(e)}else this.tree.push(s)}return this}addNodes(e){return e.forEach(e=>this.addNode(e)),this}removeNode(e){const t=this.nodeMap.get(e);if(!t)return console.warn(`节点 ${e} 不存在`),this;const n=t.__parentId;if(n){const t=this.nodeMap.get(n);if(t&&t[this.config.childrenKey]){const n=t[this.config.childrenKey].findIndex(t=>t[this.config.idKey]===e);-1!==n&&t[this.config.childrenKey].splice(n,1)}}else{const t=this.tree.findIndex(t=>t[this.config.idKey]===e);-1!==t&&this.tree.splice(t,1)}const s=e=>{e[this.config.childrenKey]&&e[this.config.childrenKey].forEach(e=>{const t=e[this.config.idKey];this.nodeMap.delete(t),s(e)})};return s(t),this.nodeMap.delete(e),this}updateNode(e,t){const n=this.nodeMap.get(e);if(!n)return console.warn(`节点 ${e} 不存在，将尝试添加`),this.addNode({[this.config.idKey]:e,...t});Object.assign(n,t);const s=t[this.config.parentKey];return void 0!==s&&s!==n.__parentId?(this.removeNode(e),this.addNode({...n,...t})):this}findNode(e){return this.nodeMap.get(e)}getTree(){return this.tree}reset(){return this.tree=[],this.nodeMap.clear(),this}getNodeCount(){return this.nodeMap.size}getRootCount(){return this.tree.length}},exports.MinimalStrategy=n,exports.RecursiveStrategy=i,exports.SmartTreeBuilder=class{constructor(e={}){this.plugins=[],this.cache=new Map,this.stats=[],this.config={idKey:"id",parentKey:"parentId",childrenKey:"children",rootParentId:0,enableGhostNodes:!1,validateNodes:!0,maxDepth:1e3,enableCache:!1,...e}}use(e){return this.plugins.push(e),this.plugins.sort((e,t)=>(e.priority||100)-(t.priority||100)),this}build(n){if(!n)return[];const s=performance.now(),i=this.generateCacheKey(n);if(this.config.enableCache&&this.cache.has(i)){console.log("使用缓存结果");const e=this.cache.get(i),t={totalNodes:n.length,rootNodes:e?.length||0,maxDepth:this.calculateMaxDepth(e||[]),buildTime:0,memoryUsed:0,cyclesDetected:0,ghostNodesCreated:0,cacheHit:!0};return this.stats.push(t),e}const o=this.selectStrategy(n);let r;console.log(`选择构建策略: ${o.name}`);const a=this.applyBeforeBuild(n),c=a||n;switch(o.name){case"minimal":default:r=e(c,this.config);break;case"enhanced":r=t(c,this.config);break;case"incremental":r=this.buildIncremental(c)}r=this.applyAfterBuild(r,n);const h=performance.now(),d={totalNodes:n.length,rootNodes:r.length,maxDepth:this.calculateMaxDepth(r),buildTime:h-s,memoryUsed:this.getMemoryUsage(),cyclesDetected:0,ghostNodesCreated:0};return this.stats.push(d),this.config.enableCache&&this.cache.set(i,r),r.__stats=d,r}getStats(){return this.stats}clearCache(){this.cache.clear()}reset(){this.plugins=[],this.cache.clear(),this.stats=[]}generateCacheKey(e){const t=JSON.stringify(this.config);if(!e)return`${t}:null:0`;return`${t}:${JSON.stringify(e.slice(0,Math.min(10,e.length)))}:${e.length}`}selectStrategy(e){if(e.length<1e3)return{name:"minimal",description:"最小化构建策略"};return this.plugins.length>0||this.config.enableGhostNodes||1e3!==this.config.maxDepth?{name:"enhanced",description:"增强构建策略"}:{name:"minimal",description:"最小化构建策略"}}applyBeforeBuild(e){let t=e;for(const e of this.plugins)e.onNodeCreated&&(t=t.map((t,n)=>{const s={level:0,path:[t[this.config.idKey||"id"]],isLeaf:!0,childCount:0};return e.onNodeCreated?.(t,s),t}));return t}applyAfterBuild(e,t){let n=e;for(const e of this.plugins)if(e.onTreeBuilt){const s=e.onTreeBuilt(n,{originalList:t});s&&(n=s)}return n}buildIncremental(t){const n=e(t,this.config);return this.optimizeTreeStructure(n),n}optimizeTreeStructure(e){this.flattenDeepNesting(e,this.config.maxDepth||1e3)}flattenDeepNesting(e,t){const n=this.config.childrenKey||"children";function s(s,i){if(i>=t&&s[n]?.length>0){const o={...s,[n]:[]},r=(s,i)=>{for(const a of s)i>=t?e.push(a):o[n].push(a),r(a[n]||[],i+1)};return r(s[n]||[],i),o}return s}for(let t=0;t<e.length;t++)e[t]=s(e[t],1)}calculateMaxDepth(e){const t=this.config.childrenKey||"children";let n=0;function s(e,i){n=Math.max(n,i);const o=e[t];if(Array.isArray(o))for(const e of o)s(e,i+1)}for(const t of e)s(t,1);return n}getMemoryUsage(){if("undefined"!=typeof process&&process.memoryUsage){return process.memoryUsage().heapUsed/1024/1024}return 0}},exports.StrategyFactory=class{static selectStrategy(e,t={}){const i=e.length,o=t.enableGhostNodes||t.detectCycles||t.sortChildren;return i<1e3&&!o?new n:i>=1e3||o?new s:new n}static getAllStrategies(){return[new n,new s,new i]}};
//# sourceMappingURL=index.js.map
