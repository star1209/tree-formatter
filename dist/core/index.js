"use strict";exports.buildEnhancedTree=function(e,t={},n){const o=t.idKey||"id",r=t.parentKey||"parentId",s=t.childrenKey||"children",a=t.rootParentId??0,i=t.enableGhostNodes||!1,d=!1!==t.validateNodes,l=t.maxDepth||1e3,c=t.detectCycles||!1,h=t.onCycleDetected||((e,t)=>{console.warn(`发现循环引用，路径: ${t.join(" -> ")}`)}),f=t.sortChildren,p=t.formatNode,u=t.isRootNode,g=performance.now(),m=process.memoryUsage?.()?.heapUsed||0,y={totalNodes:0,rootNodes:0,maxDepth:0,buildTime:0,memoryUsed:0,cyclesDetected:0,ghostNodesCreated:0};if(!Array.isArray(e)||0===e.length)return[];const I=new Map;for(const C of e){const M=C[o],A=C[r]??null;d&&null==M?console.warn(`节点缺少ID字段 "${o}"，将被忽略:`,C):M!==A?I.set(M,{original:C,formatted:null,parentId:A,children:[],depth:0}):c&&(h(C,[M]),y.cyclesDetected++)}if(y.totalNodes=I.size,c&&I.size>0){const U=new Set,v=new Set,S=[];function T(e){if(v.has(e)){const t=S.indexOf(e);if(-1!==t){const n=S.slice(t);h(I.get(e).original,n),y.cyclesDetected++}return}if(U.has(e))return;U.add(e),v.add(e),S.push(e);const t=I.get(e);if(t&&null!==t.parentId){const n=t.parentId;I.has(n)&&e!==n&&T(n)}v.delete(e),S.pop()}I.forEach((e,t)=>{U.has(t)||T(t)})}const w=new Map;for(const[E,F]of I){const{parentId:P}=F;if(E!==P&&null!=P){if(I.get(P))w.has(P)||w.set(P,[]),w.get(P).push(F);else if(i){const j=P,z={original:{[o]:j},formatted:null,parentId:null,children:[],depth:0,isGhost:!0};I.set(j,z),w.has(j)||w.set(j,[]),w.get(j).push(F),y.ghostNodesCreated++}}}const K=[],D=[],N=new Set,x=[];I.forEach((e,t)=>{const{parentId:n,isGhost:o}=e;let r=!1;r=u?u(e.original):null==n||n===a,r&&(x.push({nodeInfo:e,id:t}),y.rootNodes++)}),x.sort((e,t)=>e.id-t.id);for(let L=x.length-1;L>=0;L--){const{nodeInfo:O,id:R}=x[L];D.push({nodeInfo:O,parentFormatted:null,depth:1,path:[R]})}for(;D.length>0;){const{nodeInfo:k,parentFormatted:q,depth:B,path:H}=D.pop();if(y.maxDepth=Math.max(y.maxDepth,B),B>l){console.warn(`节点 "${H.join(" -> ")}" 深度超过限制: ${B}`);continue}const J=k.original[o];if(N.has(J))continue;N.add(J);let Q=null;q&&(Q={...q},Q[s]&&delete Q[s]);const V=w.get(J)||[],W={level:B,path:H,isLeaf:0===V.length,parent:Q,childCount:V.length};let X;if(X=n?n(k.original,W):p?p(k.original,W):{...k.original},k.isGhost&&(X.__isGhost=!0),k.parentId?X.__parentId=k.parentId:X.__parentId=null,X[s]=[],k.formatted=X,q||K.push(X),f&&V.length>0)try{V.sort((e,t)=>f(e.original,t.original))}catch(Y){console.warn("子节点排序失败:",Y)}for(let Z=V.length-1;Z>=0;Z--){const ee=V[Z],te=ee.original[o],ne=[...H,te],oe=B+1;D.push({nodeInfo:ee,parentFormatted:X,depth:oe,path:ne})}}const $=new Map;I.forEach((e,t)=>{e.formatted&&$.set(e.formatted,t)});const _=[...K];for(;_.length>0;){const re=_.pop(),se=$.get(re),ae=[],ie=w.get(se)||[];for(const de of ie)de.formatted&&(ae.push(de.formatted),_.push(de.formatted));re[s]=ae}const b=performance.now(),G=process.memoryUsage?.()?.heapUsed||0;return y.buildTime=b-g,y.memoryUsed=(G-m)/1048576,K.__stats=y,K},exports.buildMinimalTree=function(e,t={}){const n={idKey:"id",parentKey:"parentId",childrenKey:"children",rootParentId:0,enableGhostNodes:!1,validateNodes:!0,maxDepth:1e3,enableCache:!1,...t};if(!Array.isArray(e)||0===e.length)return[];const o=new Map,r=[];for(const t of e){const e=t[n.idKey];n.validateNodes&&null==e?console.warn(`节点缺少ID字段 "${n.idKey}"，将被忽略:`,t):(o.has(e)&&console.warn(`发现重复ID "${e}"，后一个节点将覆盖前一个`),o.set(e,{...t,[n.childrenKey]:[]}))}const s=new Set;for(const t of e){const e=t[n.idKey],a=t[n.parentKey],i=o.get(e);if(!i)continue;if(s.has(e))continue;s.add(e);if(null==a||a===n.rootParentId)r.push(i);else{const t=o.get(a);if(t)t[n.childrenKey].push(i);else if(n.enableGhostNodes){const e={[n.idKey]:a,[n.childrenKey]:[i],__isGhost:!0};o.set(a,e),r.push(e)}else console.warn(`父节点 "${a}" 不存在，节点 "${e}" 将被作为根节点`),r.push(i)}}return r},exports.validateMinimalTree=function(e,t={}){const n=new Set,o=t.childrenKey||"children";function r(e,s){const a=e[t.idKey||"id"];if(n.has(a))return console.error(`发现循环引用，节点ID: ${a}`),!1;if(n.add(a),s>(t.maxDepth||1e3))return console.error(`树深度超过限制: ${s}`),!1;const i=e[o];if(Array.isArray(i))for(const e of i)if(!r(e,s+1))return!1;return n.delete(a),!0}try{for(const t of e)if(!r(t,1))return!1;return!0}catch(e){return console.error("树验证失败:",e),!1}};
//# sourceMappingURL=index.js.map
