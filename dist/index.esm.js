function e(e,t={}){const n={idKey:"id",parentKey:"parentId",childrenKey:"children",rootParentId:0,enableGhostNodes:!1,validateNodes:!0,maxDepth:1e3,enableCache:!1,...t};if(!Array.isArray(e)||0===e.length)return[];const r=new Map,o=[];for(const t of e){const e=t[n.idKey];n.validateNodes&&null==e?console.warn(`节点缺少ID字段 "${n.idKey}"，将被忽略:`,t):(r.has(e)&&console.warn(`发现重复ID "${e}"，后一个节点将覆盖前一个`),r.set(e,{...t,[n.childrenKey]:[]}))}const i=new Set;for(const t of e){const e=t[n.idKey],s=t[n.parentKey],c=r.get(e);if(!c)continue;if(i.has(e))continue;i.add(e);if(null==s||s===n.rootParentId)o.push(c);else{const t=r.get(s);if(t)t[n.childrenKey].push(c);else if(n.enableGhostNodes){const e={[n.idKey]:s,[n.childrenKey]:[c],__isGhost:!0};r.set(s,e),o.push(e)}else console.warn(`父节点 "${s}" 不存在，节点 "${e}" 将被作为根节点`),o.push(c)}}return o}function t(e,t={}){const n=new Set,r=t.childrenKey||"children";function o(e,i){const s=e[t.idKey||"id"];if(n.has(s))return console.error(`发现循环引用，节点ID: ${s}`),!1;if(n.add(s),i>(t.maxDepth||1e3))return console.error(`树深度超过限制: ${i}`),!1;const c=e[r];if(Array.isArray(c))for(const e of c)if(!o(e,i+1))return!1;return n.delete(s),!0}try{for(const t of e)if(!o(t,1))return!1;return!0}catch(e){return console.error("树验证失败:",e),!1}}function n(e,t={},n){const r=t.idKey||"id",o=t.parentKey||"parentId",i=t.childrenKey||"children",s=t.rootParentId??0,c=t.enableGhostNodes||!1,l=!1!==t.validateNodes,a=t.maxDepth||1e3,h=t.detectCycles||!1,d=t.onCycleDetected||((e,t)=>{console.warn(`发现循环引用，路径: ${t.join(" -> ")}`)}),f=t.sortChildren,u=t.formatNode,p=t.isRootNode,g=performance.now(),m=process.memoryUsage?.()?.heapUsed||0,y={totalNodes:0,rootNodes:0,maxDepth:0,buildTime:0,memoryUsed:0,cyclesDetected:0,ghostNodesCreated:0};if(!Array.isArray(e)||0===e.length)return[];const N=new Map,w=[];for(const t of e){const e=t[r],s=t[o]??null;if(l&&null==e){console.warn(`节点缺少ID字段 "${r}"，将被忽略:`,t);continue}if(e===s){h&&(d(t,[e]),y.cyclesDetected++);continue}const c={level:0,path:[e],isLeaf:!0,childCount:0};let a;n?(a=n(t,c),a[i]=[]):u?(a=u(t,c),a[i]=[]):a={...t,[i]:[]},N.set(e,{original:t,formatted:a,parentId:s,children:[],depth:0})}if(y.totalNodes=N.size,h&&N.size>0){const e=new Set;for(const[t,n]of N)n.parentId===t&&(y.cyclesDetected++,d(n.original,[t]),e.add(t));e.forEach(e=>{N.delete(e)})}for(const[e,t]of N){if(t.isGhost)continue;const{parentId:e}=t;if(p?p(t.original):null==e||e===s)w.push(t.formatted),t.depth=1,y.rootNodes++;else{const n=N.get(e);if(n)n.children.push(t),t.formatted.__parentId=e;else if(c){const n=N.get(e);if(n)n.children.push(t),t.formatted.__parentId=e,t.depth=n.depth+1;else{const n={[r]:e,[i]:[t.formatted],__isGhost:!0,__parentId:null},o={original:{[r]:e},formatted:n,parentId:null,children:[t],depth:1,isGhost:!0};N.set(e,o),w.push(n),t.formatted.__parentId=e,t.depth=2,y.ghostNodesCreated++,y.rootNodes++}}else w.push(t.formatted),t.depth=1,y.rootNodes++}}const D=[];for(w.forEach(e=>{for(const[t,n]of N)if(n.formatted===e){D.push({nodeInfo:n,formattedNode:e,depth:1,path:[t]});break}});D.length>0;){const{nodeInfo:e,formattedNode:t,depth:o,path:s}=D.pop();if(y.maxDepth=Math.max(y.maxDepth,o),o>a){console.warn(`节点 "${s.join(" -> ")}" 深度超过限制: ${o}`);continue}const c=e.children;if(f&&c.length>0)try{c.sort((e,t)=>f(e.original,t.original))}catch(e){console.warn("子节点排序失败:",e)}const l=[];for(const a of c){const c=a.original[r],h=[...s,c],d=o+1;a.depth=d;let f=a.formatted;const p={level:d,path:h,isLeaf:0===a.children.length,parent:t,childCount:a.children.length};n?f={...n(a.original,p),[i]:[]}:u&&(f={...u(a.original,p),[i]:[]}),f.__parentId=e.original[r],l.push(f),a.formatted=f,D.push({nodeInfo:a,formattedNode:f,depth:d,path:h})}t[i]=l;const h={level:o,path:s,isLeaf:0===l.length,childCount:l.length};n?(Object.assign(t,n(e.original,h)),t[i]=l):u&&(Object.assign(t,u(e.original,h)),t[i]=l)}if(f&&w.length>1)try{w.sort((e,t)=>{const n=e[r],o=t[r],i=N.get(n),s=N.get(o);return i&&s?f(i.original,s.original):0})}catch(e){console.warn("根节点排序失败:",e)}const $=performance.now(),b=process.memoryUsage?.()?.heapUsed||0;return y.buildTime=$-g,y.memoryUsed=(b-m)/1048576,w.length>0&&(w.__stats=y),w}class r{constructor(e={}){this.plugins=[],this.cache=new Map,this.stats=[],this.config={idKey:"id",parentKey:"parentId",childrenKey:"children",rootParentId:0,enableGhostNodes:!1,validateNodes:!0,maxDepth:1e3,enableCache:!1,...e}}use(e){return this.plugins.push(e),this.plugins.sort((e,t)=>(e.priority||100)-(t.priority||100)),this}build(t){if(!t)return[];const r=performance.now(),o=this.generateCacheKey(t);if(this.config.enableCache&&this.cache.has(o)){console.log("使用缓存结果");const e=this.cache.get(o),n={totalNodes:t.length,rootNodes:e?.length||0,maxDepth:this.calculateMaxDepth(e||[]),buildTime:0,memoryUsed:0,cyclesDetected:0,ghostNodesCreated:0,cacheHit:!0};return this.stats.push(n),e}const i=this.selectStrategy(t);let s;console.log(`选择构建策略: ${i.name}`);const c=this.applyBeforeBuild(t),l=c||t;switch(i.name){case"minimal":default:s=e(l,this.config);break;case"enhanced":s=n(l,this.config);break;case"incremental":s=this.buildIncremental(l)}s=this.applyAfterBuild(s,t);const a=performance.now(),h={totalNodes:t.length,rootNodes:s.length,maxDepth:this.calculateMaxDepth(s),buildTime:a-r,memoryUsed:this.getMemoryUsage(),cyclesDetected:0,ghostNodesCreated:0};return this.stats.push(h),this.config.enableCache&&this.cache.set(o,s),s.__stats=h,s}getStats(){return this.stats}clearCache(){this.cache.clear()}reset(){this.plugins=[],this.cache.clear(),this.stats=[]}generateCacheKey(e){const t=JSON.stringify(this.config);if(!e)return`${t}:null:0`;return`${t}:${JSON.stringify(e.slice(0,Math.min(10,e.length)))}:${e.length}`}selectStrategy(e){if(e.length<1e3)return{name:"minimal",description:"最小化构建策略"};return this.plugins.length>0||this.config.enableGhostNodes||1e3!==this.config.maxDepth?{name:"enhanced",description:"增强构建策略"}:{name:"minimal",description:"最小化构建策略"}}applyBeforeBuild(e){let t=e;for(const e of this.plugins)e.onNodeCreated&&(t=t.map((t,n)=>{const r={level:0,path:[t[this.config.idKey||"id"]],isLeaf:!0,childCount:0};return e.onNodeCreated?.(t,r),t}));return t}applyAfterBuild(e,t){let n=e;for(const e of this.plugins)if(e.onTreeBuilt){const r=e.onTreeBuilt(n,{originalList:t});r&&(n=r)}return n}buildIncremental(t){const n=e(t,this.config);return this.optimizeTreeStructure(n),n}optimizeTreeStructure(e){this.flattenDeepNesting(e,this.config.maxDepth||1e3)}flattenDeepNesting(e,t){const n=this.config.childrenKey||"children";function r(r,o){if(o>=t&&r[n]?.length>0){const i={...r,[n]:[]},s=(r,o)=>{for(const c of r)o>=t?e.push(c):i[n].push(c),s(c[n]||[],o+1)};return s(r[n]||[],o),i}return r}for(let t=0;t<e.length;t++)e[t]=r(e[t],1)}calculateMaxDepth(e){const t=this.config.childrenKey||"children";let n=0;function r(e,o){n=Math.max(n,o);const i=e[t];if(Array.isArray(i))for(const e of i)r(e,o+1)}for(const t of e)r(t,1);return n}getMemoryUsage(){if("undefined"!=typeof process&&process.memoryUsage){return process.memoryUsage().heapUsed/1024/1024}return 0}}class o{constructor(){this.plugins=new Map}register(e){this.plugins.has(e.name)&&console.warn(`插件 "${e.name}" 已存在，将被覆盖`),this.plugins.set(e.name,e)}unregister(e){return this.plugins.delete(e)}getPlugin(e){return this.plugins.get(e)}getAllPlugins(){return Array.from(this.plugins.values()).sort((e,t)=>(e.priority||100)-(t.priority||100))}applyNodeCreated(e,t){let n=e;for(const e of this.getAllPlugins())e.onNodeCreated&&e.onNodeCreated(n,t);return n}applyNodeLinked(e,t,n){let r=!0;for(const o of this.getAllPlugins())if(o.onNodeLinked){if(!1===o.onNodeLinked(e,t,n)){r=!1;break}}return r}applyTreeBuilt(e,t){let n=e;for(const e of this.getAllPlugins())if(e.onTreeBuilt){const r=e.onTreeBuilt(n,t);r&&(n=r)}return n}clear(){this.plugins.clear()}get count(){return this.plugins.size}}function i(e={}){const t={throwOnCycle:!1,fixStrategy:"remove",...e},n=new Set,r=new Set,o=[],i=(e,t)=>{const n=function e(n){return n.filter(n=>!t.has(n.id)&&(n.children&&n.children.length>0&&(n.children=e(n.children)),!0))}(e);e.length=0,e.push(...n)},s=(e,t,n)=>{!function e(r){for(let o=0;o<r.length;o++){const i=r[o];if(i.id===t&&i.children){const e=i.children.findIndex(e=>e.id===n);if(-1!==e)return i.children.splice(e,1),console.log(`已断开链接: ${t} -> ${n}`),!0}if(i.children&&i.children.length>0&&e(i.children))return!0}return!1}(e)};return{name:"cycle-detection",priority:10,onNodeLinked(e,n,i){const s=e.id,c=n.id;if(s===c){if(console.error(`发现自循环引用: ${s} -> ${c}`),t.throwOnCycle)throw new Error(`循环引用: ${s} -> ${c}`);return o.push([s,c]),"remove"===t.fixStrategy}if(r.add(s),r.has(c)){const e=Array.from(r),n=e.indexOf(c),i=e.slice(n);if(i.push(c),console.error(`发现循环引用: ${i.join(" -> ")}`),o.push(i),t.throwOnCycle)throw new Error(`循环引用: ${i.join(" -> ")}`);return r.delete(s),"remove"===t.fixStrategy}return r.delete(s),!0},onTreeBuilt(e){o.length>0&&(console.warn(`检测到 ${o.length} 个循环引用`),"remove"===t.fixStrategy?(e=>{const t=new Set;o.forEach(e=>{const n=e[e.length-1];t.add(n)}),i(e,t)})(e):"break"===t.fixStrategy&&(e=>{o.forEach(t=>{const n=t[t.length-2],r=t[t.length-1];s(e,n,r)})})(e)),n.clear(),r.clear()}}}function s(){const e=new Map,t=new Map;return{name:"topological-detector",priority:5,onNodeLinked(n,r){const o=n.id,i=r.id;e.has(o)||e.set(o,new Set),t.has(i)||t.set(i,0),t.has(o)||t.set(o,0),e.get(o).add(i),t.set(i,(t.get(i)||0)+1)},onTreeBuilt(){const n=[],r=[];for(t.forEach((e,t)=>{0===e&&n.push(t)});n.length>0;){const o=n.shift();r.push(o);const i=e.get(o);i&&i.forEach(e=>{const r=(t.get(e)||1)-1;t.set(e,r),0===r&&n.push(e)})}if(r.length!==e.size){console.error(`检测到循环引用，拓扑排序失败，共有 ${e.size} 个节点，排序了 ${r.length} 个`);const n=new Set;t.forEach((e,t)=>{e>0&&n.add(t)}),console.error(`环中的节点: ${Array.from(n).join(", ")}`)}e.clear(),t.clear()}}}function c(e,t={}){const n={scope:"all",recursive:!0,timing:"after",...t};return{name:"sorting",priority:50,onTreeBuilt:t=>"after"===n.timing?l(t,e,n):t,onNodeLinked(t,r){if("during"===n.timing&&"root"!==n.scope&&t.children&&Array.isArray(t.children))try{t.children.sort(e)}catch(e){console.warn("节点排序失败:",e)}}}}function l(e,t,n){if(!e||!Array.isArray(e)||0===e.length)return e;let r=[...e];try{if("all"!==n.scope&&"root"!==n.scope||r.sort(t),n.recursive&&("all"===n.scope||"children"===n.scope))for(const e of r)e.children&&Array.isArray(e.children)&&e.children.length>0&&(e.children=l(e.children,t,n))}catch(e){console.error("树排序失败:",e)}return r}function a(e){const t=function(e){return(t,n)=>{for(const r of e){const e=t[r.key],o=n[r.key];let i=0;if("number"===r.type){i=(Number(e)||0)-(Number(o)||0)}else if("date"===r.type){i=(e?new Date(e).getTime():0)-(o?new Date(o).getTime():0)}else{const t=String(e||""),n=String(o||"");i=t.localeCompare(n)}if("desc"===r.order&&(i=-i),0!==i)return i}return 0}}(e);return c(t,{scope:"all",recursive:!0,timing:"after"})}function h(t,r={}){return t.length<1e3?e(t,r):n(t,r)}function d(e,t={},r){return n(e,t,r)}function f(e=[],t={}){const n=new r(t);return e.forEach(e=>{n.use(e)}),n}const u="1.0.0",p="Tree Formatter Library",g="高性能、模块化的树形结构构建库";export{p as AUTHOR,g as DESCRIPTION,o as PluginManager,r as SmartTreeBuilder,u as VERSION,n as buildEnhancedTree,e as buildMinimalTree,d as createAdvancedTree,i as createCycleDetectionPlugin,a as createMultiLevelSorting,f as createPluginTreeBuilder,c as createSortingPlugin,s as createTopologicalDetector,h as createTree,t as validateMinimalTree};
//# sourceMappingURL=index.esm.js.map
