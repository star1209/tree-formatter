function e(e,t={}){const n={idKey:"id",parentKey:"parentId",childrenKey:"children",rootParentId:0,enableGhostNodes:!1,validateNodes:!0,maxDepth:1e3,enableCache:!1,...t};if(!Array.isArray(e)||0===e.length)return[];const s=new Map,o=[];for(const t of e){const e=t[n.idKey];n.validateNodes&&null==e?console.warn(`节点缺少ID字段 "${n.idKey}"，将被忽略:`,t):(s.has(e)&&console.warn(`发现重复ID "${e}"，后一个节点将覆盖前一个`),s.set(e,{...t,[n.childrenKey]:[]}))}const i=new Set;for(const t of e){const e=t[n.idKey],r=t[n.parentKey],a=s.get(e);if(!a)continue;if(i.has(e))continue;i.add(e);if(null==r||r===n.rootParentId)o.push(a);else{const t=s.get(r);if(t)t[n.childrenKey].push(a);else if(n.enableGhostNodes){const e={[n.idKey]:r,[n.childrenKey]:[a],__isGhost:!0};s.set(r,e),o.push(e)}else console.warn(`父节点 "${r}" 不存在，节点 "${e}" 将被作为根节点`),o.push(a)}}return function e(t){for(const s of t)Array.isArray(s[n.childrenKey])&&0===s[n.childrenKey].length?delete s[n.childrenKey]:e(s[n.childrenKey])}(o),o}function t(e,t={},n){const s=t.idKey||"id",o=t.parentKey||"parentId",i=t.childrenKey||"children",r=t.rootParentId??0,a=t.enableGhostNodes||!1,c=!1!==t.validateNodes,h=t.maxDepth||1e3,d=t.detectCycles||!1,l=t.onCycleDetected||((e,t)=>{console.warn(`发现循环引用，路径: ${t.join(" -> ")}`)}),p=t.sortChildren,f=t.formatNode,u=t.isRootNode,g=performance.now(),y=process.memoryUsage?.()?.heapUsed||0,m={totalNodes:0,rootNodes:0,maxDepth:0,buildTime:0,memoryUsed:0,cyclesDetected:0,ghostNodesCreated:0};if(!Array.isArray(e)||0===e.length)return[];const K=new Map;for(const $ of e){const G=$[s],A=$[o]??null;c&&null==G?console.warn(`节点缺少ID字段 "${s}"，将被忽略:`,$):G!==A?K.set(G,{original:$,formatted:null,parentId:A,children:[],depth:0}):d&&(l($,[G]),m.cyclesDetected++)}if(m.totalNodes=K.size,d&&K.size>0){const S=new Set,U=new Set,v=[];function T(e){if(U.has(e)){const t=v.indexOf(e);if(-1!==t){const n=v.slice(t);l(K.get(e).original,n),m.cyclesDetected++}return}if(S.has(e))return;S.add(e),U.add(e),v.push(e);const t=K.get(e);if(t&&null!==t.parentId){const n=t.parentId;K.has(n)&&e!==n&&T(n)}U.delete(e),v.pop()}K.forEach((e,t)=>{S.has(t)||T(t)})}const N=new Map;for(const[B,E]of K){const{parentId:P}=E;if(B!==P&&null!=P){if(K.get(P))N.has(P)||N.set(P,[]),N.get(P).push(E);else if(a){const z=P,O={original:{[s]:z},formatted:null,parentId:null,children:[],depth:0,isGhost:!0};K.set(z,O),N.has(z)||N.set(z,[]),N.get(z).push(E),m.ghostNodesCreated++}}}const I=[],w=[],M=new Set,b=[];K.forEach((e,t)=>{const{parentId:n,isGhost:s}=e;let o=!1;o=u?u(e.original):null==n||n===r,o&&(b.push({nodeInfo:e,id:t}),m.rootNodes++)}),b.sort((e,t)=>e.id-t.id);for(let j=b.length-1;j>=0;j--){const{nodeInfo:F,id:L}=b[j];w.push({nodeInfo:F,parentFormatted:null,depth:1,path:[L]})}for(;w.length>0;){const{nodeInfo:k,parentFormatted:J,depth:R,path:H}=w.pop();if(m.maxDepth=Math.max(m.maxDepth,R),R>h){console.warn(`节点 "${H.join(" -> ")}" 深度超过限制: ${R}`);continue}const q=k.original[s];if(M.has(q))continue;M.add(q);let Q=null;J&&(Q={...J},Q[i]&&delete Q[i]);const V=N.get(q)||[],W={level:R,path:H,isLeaf:0===V.length,parent:Q,childCount:V.length};let X;if(X=n?n(k.original,W):f?f(k.original,W):{...k.original},k.isGhost&&(X.__isGhost=!0),k.parentId?X.__parentId=k.parentId:X.__parentId=null,X[i]=[],k.formatted=X,J||I.push(X),p&&V.length>0)try{V.sort((e,t)=>p(e.original,t.original))}catch(Y){console.warn("子节点排序失败:",Y)}for(let Z=V.length-1;Z>=0;Z--){const ee=V[Z],te=ee.original[s],ne=[...H,te],se=R+1;w.push({nodeInfo:ee,parentFormatted:X,depth:se,path:ne})}}const D=new Map;K.forEach((e,t)=>{e.formatted&&D.set(e.formatted,t)});const C=[...I];for(;C.length>0;){const oe=C.pop(),ie=D.get(oe),re=[],ae=N.get(ie)||[];for(const ce of ae)ce.formatted&&(re.push(ce.formatted),C.push(ce.formatted));oe[i]=re}const x=performance.now(),_=process.memoryUsage?.()?.heapUsed||0;return m.buildTime=x-g,m.memoryUsed=(_-y)/1048576,I.__stats=m,function e(t){for(const n of t)Array.isArray(n[i])&&0===n[i].length?delete n[i]:e(n[i]||[])}(I),I}class n{constructor(e={}){this.plugins=[],this.cache=new Map,this.stats=[],this.config={idKey:"id",parentKey:"parentId",childrenKey:"children",rootParentId:0,enableGhostNodes:!1,validateNodes:!0,maxDepth:1e3,enableCache:!1,...e}}use(e){return this.plugins.push(e),this.plugins.sort((e,t)=>(e.priority||100)-(t.priority||100)),this}build(n){if(!n)return[];const s=performance.now(),o=this.generateCacheKey(n);if(this.config.enableCache&&this.cache.has(o)){console.log("使用缓存结果");const e=this.cache.get(o),t={totalNodes:n.length,rootNodes:e?.length||0,maxDepth:this.calculateMaxDepth(e||[]),buildTime:0,memoryUsed:0,cyclesDetected:0,ghostNodesCreated:0,cacheHit:!0};return this.stats.push(t),e}const i=this.selectStrategy(n);let r;console.log(`选择构建策略: ${i.name}`);const a=this.applyBeforeBuild(n),c=a||n;switch(i.name){case"minimal":default:r=e(c,this.config);break;case"enhanced":r=t(c,this.config);break;case"incremental":r=this.buildIncremental(c)}r=this.applyAfterBuild(r,n);const h=performance.now(),d={totalNodes:n.length,rootNodes:r.length,maxDepth:this.calculateMaxDepth(r),buildTime:h-s,memoryUsed:this.getMemoryUsage(),cyclesDetected:0,ghostNodesCreated:0};return this.stats.push(d),this.config.enableCache&&this.cache.set(o,r),r.__stats=d,r}getStats(){return this.stats}clearCache(){this.cache.clear()}reset(){this.plugins=[],this.cache.clear(),this.stats=[]}generateCacheKey(e){const t=JSON.stringify(this.config);if(!e)return`${t}:null:0`;return`${t}:${JSON.stringify(e.slice(0,Math.min(10,e.length)))}:${e.length}`}selectStrategy(e){if(e.length<1e3)return{name:"minimal",description:"最小化构建策略"};return this.plugins.length>0||this.config.enableGhostNodes||1e3!==this.config.maxDepth?{name:"enhanced",description:"增强构建策略"}:{name:"minimal",description:"最小化构建策略"}}applyBeforeBuild(e){let t=e;for(const e of this.plugins)e.onNodeCreated&&(t=t.map((t,n)=>{const s={level:0,path:[t[this.config.idKey||"id"]],isLeaf:!0,childCount:0};return e.onNodeCreated?.(t,s),t}));return t}applyAfterBuild(e,t){let n=e;for(const e of this.plugins)if(e.onTreeBuilt){const s=e.onTreeBuilt(n,{originalList:t});s&&(n=s)}return n}buildIncremental(t){const n=e(t,this.config);return this.optimizeTreeStructure(n),n}optimizeTreeStructure(e){this.flattenDeepNesting(e,this.config.maxDepth||1e3)}flattenDeepNesting(e,t){const n=this.config.childrenKey||"children";function s(s,o){if(o>=t&&s[n]?.length>0){const i={...s,[n]:[]},r=(s,o)=>{for(const a of s)o>=t?e.push(a):i[n].push(a),r(a[n]||[],o+1)};return r(s[n]||[],o),i}return s}for(let t=0;t<e.length;t++)e[t]=s(e[t],1)}calculateMaxDepth(e){const t=this.config.childrenKey||"children";let n=0;function s(e,o){n=Math.max(n,o);const i=e[t];if(Array.isArray(i))for(const e of i)s(e,o+1)}for(const t of e)s(t,1);return n}getMemoryUsage(){if("undefined"!=typeof process&&process.memoryUsage){return process.memoryUsage().heapUsed/1024/1024}return 0}}class s{constructor(e={}){this.tree=[],this.nodeMap=new Map,this.config={idKey:"id",parentKey:"parentId",childrenKey:"children",rootParentId:0,enableGhostNodes:!1,validateNodes:!0,maxDepth:1e3,enableCache:!1,...e}}addNode(e){const t=e[this.config.idKey],n=e[this.config.parentKey]??null;if(this.nodeMap.has(t))return console.warn(`节点 ${t} 已存在，将更新该节点`),this.updateNode(t,e);const s={...e,[this.config.childrenKey]:[]};this.nodeMap.set(t,s);if(null==n||n===this.config.rootParentId||!this.nodeMap.has(n))this.tree.push(s);else{const e=this.nodeMap.get(n);if(e)e[this.config.childrenKey].push(s);else if(this.config.enableGhostNodes){const e={[this.config.idKey]:n,[this.config.childrenKey]:[s],__isGhost:!0};this.nodeMap.set(n,e),this.tree.push(e)}else this.tree.push(s)}return this}addNodes(e){return e.forEach(e=>this.addNode(e)),this}removeNode(e){const t=this.nodeMap.get(e);if(!t)return console.warn(`节点 ${e} 不存在`),this;const n=t.__parentId;if(n){const t=this.nodeMap.get(n);if(t&&t[this.config.childrenKey]){const n=t[this.config.childrenKey].findIndex(t=>t[this.config.idKey]===e);-1!==n&&t[this.config.childrenKey].splice(n,1)}}else{const t=this.tree.findIndex(t=>t[this.config.idKey]===e);-1!==t&&this.tree.splice(t,1)}const s=e=>{e[this.config.childrenKey]&&e[this.config.childrenKey].forEach(e=>{const t=e[this.config.idKey];this.nodeMap.delete(t),s(e)})};return s(t),this.nodeMap.delete(e),this}updateNode(e,t){const n=this.nodeMap.get(e);if(!n)return console.warn(`节点 ${e} 不存在，将尝试添加`),this.addNode({[this.config.idKey]:e,...t});Object.assign(n,t);const s=t[this.config.parentKey];return void 0!==s&&s!==n.__parentId?(this.removeNode(e),this.addNode({...n,...t})):this}findNode(e){return this.nodeMap.get(e)}getTree(){return this.tree}reset(){return this.tree=[],this.nodeMap.clear(),this}getNodeCount(){return this.nodeMap.size}getRootCount(){return this.tree.length}}class o{constructor(){this.name="minimal",this.description="最小化构建策略（对标 row-to-tree）"}build(t,n){return e(t,n)}}class i{constructor(){this.name="enhanced",this.description="增强构建策略（支持循环检测、排序等）"}build(e,n){return t(e,n)}}class r{constructor(){this.name="recursive",this.description="递归构建策略（适合深度嵌套）"}build(e,t){const n=t.idKey||"id",s=t.parentKey||"parentId",o=t.childrenKey||"children",i=t.rootParentId??0,r=new Map;e.forEach(e=>{const t=e[n];null!=t&&r.set(t,{...e,[o]:[]})});const a=(t=i)=>{const c=[];return e.forEach(e=>{const i=e[n];if(e[s]===t){const e=r.get(i);if(e){const t=a(i);e[o]=t,c.push(e)}}}),c};return a()}}class a{static selectStrategy(e,t={}){const n=e.length,s=t.enableGhostNodes||t.detectCycles||t.sortChildren;return n<1e3&&!s?new o:n>=1e3||s?new i:new o}static getAllStrategies(){return[new o,new i,new r]}}export{i as EnhancedStrategy,s as IncrementalTreeBuilder,o as MinimalStrategy,r as RecursiveStrategy,n as SmartTreeBuilder,a as StrategyFactory};
//# sourceMappingURL=index.esm.js.map
