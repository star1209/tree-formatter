function e(e,t={}){const n={idKey:"id",parentKey:"parentId",childrenKey:"children",rootParentId:0,enableGhostNodes:!1,validateNodes:!0,maxDepth:1e3,enableCache:!1,...t};if(!Array.isArray(e)||0===e.length)return[];const r=new Map,o=[];for(const t of e){const e=t[n.idKey];n.validateNodes&&null==e?console.warn(`节点缺少ID字段 "${n.idKey}"，将被忽略:`,t):(r.has(e)&&console.warn(`发现重复ID "${e}"，后一个节点将覆盖前一个`),r.set(e,{...t,[n.childrenKey]:[]}))}const s=new Set;for(const t of e){const e=t[n.idKey],i=t[n.parentKey],c=r.get(e);if(!c)continue;if(s.has(e))continue;s.add(e);if(null==i||i===n.rootParentId)o.push(c);else{const t=r.get(i);if(t)t[n.childrenKey].push(c);else if(n.enableGhostNodes){const e={[n.idKey]:i,[n.childrenKey]:[c],__isGhost:!0};r.set(i,e),o.push(e)}else console.warn(`父节点 "${i}" 不存在，节点 "${e}" 将被作为根节点`),o.push(c)}}return o}function t(e,t={}){const n=new Set,r=t.childrenKey||"children";function o(e,s){const i=e[t.idKey||"id"];if(n.has(i))return console.error(`发现循环引用，节点ID: ${i}`),!1;if(n.add(i),s>(t.maxDepth||1e3))return console.error(`树深度超过限制: ${s}`),!1;const c=e[r];if(Array.isArray(c))for(const e of c)if(!o(e,s+1))return!1;return n.delete(i),!0}try{for(const t of e)if(!o(t,1))return!1;return!0}catch(e){return console.error("树验证失败:",e),!1}}function n(e,t={},n){const r=t.idKey||"id",o=t.parentKey||"parentId",s=t.childrenKey||"children",i=t.rootParentId??0,c=t.enableGhostNodes||!1,a=!1!==t.validateNodes,l=t.maxDepth||1e3,h=t.detectCycles||!1,d=t.onCycleDetected||((e,t)=>{console.warn(`发现循环引用，路径: ${t.join(" -> ")}`)}),f=t.sortChildren,u=t.formatNode;t.isRootNode;const p=performance.now(),g=process.memoryUsage?.()?.heapUsed||0,y={totalNodes:0,rootNodes:0,maxDepth:0,buildTime:0,memoryUsed:0,cyclesDetected:0,ghostNodesCreated:0};if(!Array.isArray(e)||0===e.length)return[];const m=new Map,N=[];for(const t of e){const e=t[r],i=t[o]??null;if(a&&null==e){console.warn(`节点缺少ID字段 "${r}"，将被忽略:`,t);continue}if(e===i){h&&(d(t,[e]),y.cyclesDetected++);continue}const c={level:0,path:[e],isLeaf:!0,childCount:0};let l;n?(l=n(t,c),l[s]=[]):u?(l=u(t,c),l[s]=[]):l={...t,[s]:[]},m.set(e,{original:t,formatted:l,parentId:i,children:[],depth:0})}if(y.totalNodes=m.size,h&&m.size>0){const e=function(e){const t=new Map,n=new Map;e.forEach((e,r)=>{t.set(r,new Set),n.set(r,0)}),e.forEach((r,o)=>{const s=r.parentId;null!==s&&e.has(s)&&o!==s&&(t.get(s).add(o),n.set(o,(n.get(o)||0)+1))});const r=[],o=[];n.forEach((e,t)=>{0===e&&r.push(t)});for(;r.length>0;){const e=r.shift(),o=t.get(e);o&&o.forEach(e=>{const t=(n.get(e)||1)-1;n.set(e,t),0===t&&r.push(e)})}const s=new Set;return n.forEach((e,r)=>{if(e>0&&!s.has(r)){const e=[];let i=r;for(;!s.has(i);){s.add(i),e.push(i);const r=Array.from(t.get(i)||[]);for(const e of r)if(n.get(e)>0&&!s.has(e)){i=e;break}}e.length>0&&o.push(e)}}),o}(m);e.forEach(e=>{y.cyclesDetected++;const t=m.get(e[0]);t&&(d(t.original,e),m.delete(e[0]))})}for(const[e,t]of m){if(t.isGhost)continue;const{parentId:e}=t;if(null==e||e===i)N.push(t.formatted),t.depth=1,y.rootNodes++;else{const n=m.get(e);if(n)n.children.push(t),t.formatted.__parentId=e;else if(c){const n=m.get(e);if(n)n.children.push(t),t.formatted.__parentId=e,t.depth=n.depth+1;else{const n={[r]:e,[s]:[t.formatted],__isGhost:!0,__parentId:null},o={original:{[r]:e},formatted:n,parentId:null,children:[t],depth:1,isGhost:!0};m.set(e,o),N.push(n),t.formatted.__parentId=e,t.depth=2,y.ghostNodesCreated++,y.rootNodes++}}else N.push(t.formatted),t.depth=1,y.rootNodes++}}const w=[];for(N.forEach(e=>{const t=e[r],n=m.get(t);n&&w.push({nodeInfo:n,formattedNode:e,depth:1,path:[t]})});w.length>0;){const{nodeInfo:e,formattedNode:t,depth:o,path:i}=w.pop();if(y.maxDepth=Math.max(y.maxDepth,o),o>l){console.warn(`节点 "${i.join(" -> ")}" 深度超过限制: ${o}`);continue}const c=e.children;if(f&&c.length>0)try{c.sort((e,t)=>f(e.original,t.original))}catch(e){console.warn("子节点排序失败:",e)}const a=[];for(const l of c){const c=l.original[r],h=[...i,c],d=o+1;l.depth=d;let f=l.formatted;const p={level:d,path:h,isLeaf:0===l.children.length,parent:t,childCount:l.children.length};n?f={...n(l.original,p),[s]:[]}:u&&(f={...u(l.original,p),[s]:[]}),f.__parentId=e.original[r],a.push(f),l.formatted=f,w.push({nodeInfo:l,formattedNode:f,depth:d,path:h})}t[s]=a;const h={level:o,path:i,isLeaf:0===a.length,childCount:a.length};n?(Object.assign(t,n(e.original,h)),t[s]=a):u&&(Object.assign(t,u(e.original,h)),t[s]=a)}if(f&&N.length>1)try{N.sort((e,t)=>{const n=e[r],o=t[r],s=m.get(n),i=m.get(o);return s&&i?f(s.original,i.original):0})}catch(e){console.warn("根节点排序失败:",e)}const D=performance.now(),$=process.memoryUsage?.()?.heapUsed||0;return y.buildTime=D-p,y.memoryUsed=($-g)/1048576,N.length>0&&(N.__stats=y),N}class r{constructor(e={}){this.plugins=[],this.cache=new Map,this.stats=[],this.config={idKey:"id",parentKey:"parentId",childrenKey:"children",rootParentId:0,enableGhostNodes:!1,validateNodes:!0,maxDepth:1e3,enableCache:!1,...e}}use(e){return this.plugins.push(e),this.plugins.sort((e,t)=>(e.priority||100)-(t.priority||100)),this}build(t){if(!t)return[];const r=performance.now(),o=this.generateCacheKey(t);if(this.config.enableCache&&this.cache.has(o)){console.log("使用缓存结果");const e=this.cache.get(o),n={totalNodes:t.length,rootNodes:e?.length||0,maxDepth:this.calculateMaxDepth(e||[]),buildTime:0,memoryUsed:0,cyclesDetected:0,ghostNodesCreated:0,cacheHit:!0};return this.stats.push(n),e}const s=this.selectStrategy(t);let i;console.log(`选择构建策略: ${s.name}`);const c=this.applyBeforeBuild(t),a=c||t;switch(s.name){case"minimal":default:i=e(a,this.config);break;case"enhanced":i=n(a,this.config);break;case"incremental":i=this.buildIncremental(a)}i=this.applyAfterBuild(i,t);const l=performance.now(),h={totalNodes:t.length,rootNodes:i.length,maxDepth:this.calculateMaxDepth(i),buildTime:l-r,memoryUsed:this.getMemoryUsage(),cyclesDetected:0,ghostNodesCreated:0};return this.stats.push(h),this.config.enableCache&&this.cache.set(o,i),i.__stats=h,i}getStats(){return this.stats}clearCache(){this.cache.clear()}reset(){this.plugins=[],this.cache.clear(),this.stats=[]}generateCacheKey(e){const t=JSON.stringify(this.config);if(!e)return`${t}:null:0`;return`${t}:${JSON.stringify(e.slice(0,Math.min(10,e.length)))}:${e.length}`}selectStrategy(e){if(e.length<1e3)return{name:"minimal",description:"最小化构建策略"};return this.plugins.length>0||this.config.enableGhostNodes||1e3!==this.config.maxDepth?{name:"enhanced",description:"增强构建策略"}:{name:"minimal",description:"最小化构建策略"}}applyBeforeBuild(e){let t=e;for(const e of this.plugins)e.onNodeCreated&&(t=t.map((t,n)=>{const r={level:0,path:[t[this.config.idKey||"id"]],isLeaf:!0,childCount:0};return e.onNodeCreated?.(t,r),t}));return t}applyAfterBuild(e,t){let n=e;for(const e of this.plugins)if(e.onTreeBuilt){const r=e.onTreeBuilt(n,{originalList:t});r&&(n=r)}return n}buildIncremental(t){const n=e(t,this.config);return this.optimizeTreeStructure(n),n}optimizeTreeStructure(e){this.flattenDeepNesting(e,this.config.maxDepth||1e3)}flattenDeepNesting(e,t){const n=this.config.childrenKey||"children";function r(r,o){if(o>=t&&r[n]?.length>0){const s={...r,[n]:[]},i=(r,o)=>{for(const c of r)o>=t?e.push(c):s[n].push(c),i(c[n]||[],o+1)};return i(r[n]||[],o),s}return r}for(let t=0;t<e.length;t++)e[t]=r(e[t],1)}calculateMaxDepth(e){const t=this.config.childrenKey||"children";let n=0;function r(e,o){n=Math.max(n,o);const s=e[t];if(Array.isArray(s))for(const e of s)r(e,o+1)}for(const t of e)r(t,1);return n}getMemoryUsage(){if("undefined"!=typeof process&&process.memoryUsage){return process.memoryUsage().heapUsed/1024/1024}return 0}}class o{constructor(){this.plugins=new Map}register(e){this.plugins.has(e.name)&&console.warn(`插件 "${e.name}" 已存在，将被覆盖`),this.plugins.set(e.name,e)}unregister(e){return this.plugins.delete(e)}getPlugin(e){return this.plugins.get(e)}getAllPlugins(){return Array.from(this.plugins.values()).sort((e,t)=>(e.priority||100)-(t.priority||100))}applyNodeCreated(e,t){let n=e;for(const e of this.getAllPlugins())e.onNodeCreated&&e.onNodeCreated(n,t);return n}applyNodeLinked(e,t,n){let r=!0;for(const o of this.getAllPlugins())if(o.onNodeLinked){if(!1===o.onNodeLinked(e,t,n)){r=!1;break}}return r}applyTreeBuilt(e,t){let n=e;for(const e of this.getAllPlugins())if(e.onTreeBuilt){const r=e.onTreeBuilt(n,t);r&&(n=r)}return n}clear(){this.plugins.clear()}get count(){return this.plugins.size}}function s(e={}){const t={throwOnCycle:!1,fixStrategy:"remove",...e},n=new Set,r=new Set,o=[],s=(e,t)=>{const n=function e(n){return n.filter(n=>!t.has(n.id)&&(n.children&&n.children.length>0&&(n.children=e(n.children)),!0))}(e);e.length=0,e.push(...n)},i=(e,t,n)=>{!function e(r){for(let o=0;o<r.length;o++){const s=r[o];if(s.id===t&&s.children){const e=s.children.findIndex(e=>e.id===n);if(-1!==e)return s.children.splice(e,1),console.log(`已断开链接: ${t} -> ${n}`),!0}if(s.children&&s.children.length>0&&e(s.children))return!0}return!1}(e)};return{name:"cycle-detection",priority:10,onNodeLinked(e,n,s){const i=e.id,c=n.id;if(i===c){if(console.error(`发现自循环引用: ${i} -> ${c}`),t.throwOnCycle)throw new Error(`循环引用: ${i} -> ${c}`);return o.push([i,c]),"remove"===t.fixStrategy}if(r.add(i),r.has(c)){const e=Array.from(r),n=e.indexOf(c),s=e.slice(n);if(s.push(c),console.error(`发现循环引用: ${s.join(" -> ")}`),o.push(s),t.throwOnCycle)throw new Error(`循环引用: ${s.join(" -> ")}`);return r.delete(i),"remove"===t.fixStrategy}return r.delete(i),!0},onTreeBuilt(e){o.length>0&&(console.warn(`检测到 ${o.length} 个循环引用`),"remove"===t.fixStrategy?(e=>{const t=new Set;o.forEach(e=>{const n=e[e.length-1];t.add(n)}),s(e,t)})(e):"break"===t.fixStrategy&&(e=>{o.forEach(t=>{const n=t[t.length-2],r=t[t.length-1];i(e,n,r)})})(e)),n.clear(),r.clear()}}}function i(){const e=new Map,t=new Map;return{name:"topological-detector",priority:5,onNodeLinked(n,r){const o=n.id,s=r.id;e.has(o)||e.set(o,new Set),t.has(s)||t.set(s,0),t.has(o)||t.set(o,0),e.get(o).add(s),t.set(s,(t.get(s)||0)+1)},onTreeBuilt(){const n=[],r=[];for(t.forEach((e,t)=>{0===e&&n.push(t)});n.length>0;){const o=n.shift();r.push(o);const s=e.get(o);s&&s.forEach(e=>{const r=(t.get(e)||1)-1;t.set(e,r),0===r&&n.push(e)})}if(r.length!==e.size){console.error(`检测到循环引用，拓扑排序失败，共有 ${e.size} 个节点，排序了 ${r.length} 个`);const n=new Set;t.forEach((e,t)=>{e>0&&n.add(t)}),console.error(`环中的节点: ${Array.from(n).join(", ")}`)}e.clear(),t.clear()}}}function c(e,t={}){const n={scope:"all",recursive:!0,timing:"after",...t};return{name:"sorting",priority:50,onTreeBuilt:t=>"after"===n.timing?a(t,e,n):t,onNodeLinked(t,r){if("during"===n.timing&&"root"!==n.scope&&t.children&&Array.isArray(t.children))try{t.children.sort(e)}catch(e){console.warn("节点排序失败:",e)}}}}function a(e,t,n){if(!e||!Array.isArray(e)||0===e.length)return e;let r=[...e];try{if("all"!==n.scope&&"root"!==n.scope||r.sort(t),n.recursive&&("all"===n.scope||"children"===n.scope))for(const e of r)e.children&&Array.isArray(e.children)&&e.children.length>0&&(e.children=a(e.children,t,n))}catch(e){console.error("树排序失败:",e)}return r}function l(e){const t=function(e){return(t,n)=>{for(const r of e){const e=t[r.key],o=n[r.key];let s=0;if("number"===r.type){s=(Number(e)||0)-(Number(o)||0)}else if("date"===r.type){s=(e?new Date(e).getTime():0)-(o?new Date(o).getTime():0)}else{const t=String(e||""),n=String(o||"");s=t.localeCompare(n)}if("desc"===r.order&&(s=-s),0!==s)return s}return 0}}(e);return c(t,{scope:"all",recursive:!0,timing:"after"})}function h(t,r={}){return t.length<1e3?e(t,r):n(t,r)}function d(e,t={},r){return n(e,t,r)}function f(e=[],t={}){const n=new r(t);return e.forEach(e=>{n.use(e)}),n}const u="1.0.0",p="Tree Formatter Library",g="高性能、模块化的树形结构构建库";export{p as AUTHOR,g as DESCRIPTION,o as PluginManager,r as SmartTreeBuilder,u as VERSION,n as buildEnhancedTree,e as buildMinimalTree,d as createAdvancedTree,s as createCycleDetectionPlugin,l as createMultiLevelSorting,f as createPluginTreeBuilder,c as createSortingPlugin,i as createTopologicalDetector,h as createTree,t as validateMinimalTree};
//# sourceMappingURL=index.esm.js.map
