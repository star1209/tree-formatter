"use strict";exports.buildEnhancedTree=function(e,t={},n){const o=t.idKey||"id",r=t.parentKey||"parentId",i=t.childrenKey||"children",s=t.rootParentId??0,a=t.enableGhostNodes||!1,d=!1!==t.validateNodes,l=t.maxDepth||1e3,c=t.detectCycles||!1,h=t.onCycleDetected||((e,t)=>{console.warn(`发现循环引用，路径: ${t.join(" -> ")}`)}),f=t.sortChildren,p=t.formatNode,u=t.isRootNode;if(performance.now(),process.memoryUsage?.(),!Array.isArray(e)||0===e.length)return[];const g=new Map,y=[];for(const t of e){const e=t[o],s=t[r]??null;if(d&&null==e){console.warn(`节点缺少ID字段 "${o}"，将被忽略:`,t);continue}if(e===s){c&&h(t,[e]);continue}const a={level:0,path:[e],isLeaf:!0,childCount:0};let l;n?(l=n(t,a),l[i]=[]):p?(l=p(t,a),l[i]=[]):l={...t,[i]:[]},g.set(e,{original:t,formatted:l,parentId:s,children:[],depth:0})}if(g.size,c&&g.size>0){const e=new Set;for(const[t,n]of g)n.parentId===t&&(h(n.original,[t]),e.add(t));e.forEach(e=>{g.delete(e)})}for(const[e,t]of g){if(t.isGhost)continue;const{parentId:e}=t;if(u?u(t.original):null==e||e===s)y.push(t.formatted),t.depth=1;else{const n=g.get(e);if(n)n.children.push(t),t.formatted.__parentId=e;else if(a){const n=g.get(e);if(n)n.children.push(t),t.formatted.__parentId=e,t.depth=n.depth+1;else{const n={[o]:e,[i]:[t.formatted],__isGhost:!0,__parentId:null},r={original:{[o]:e},formatted:n,parentId:null,children:[t],depth:1,isGhost:!0};g.set(e,r),y.push(n),t.formatted.__parentId=e,t.depth=2}}else y.push(t.formatted),t.depth=1}}const m=[];for(y.forEach(e=>{for(const[t,n]of g)if(n.formatted===e){m.push({nodeInfo:n,formattedNode:e,depth:1,path:[t]});break}});m.length>0;){const{nodeInfo:e,formattedNode:t,depth:r,path:s}=m.pop();if(r>l){console.warn(`节点 "${s.join(" -> ")}" 深度超过限制: ${r}`);continue}const a=e.children;if(f&&a.length>0)try{a.sort((e,t)=>f(e.original,t.original))}catch(e){console.warn("子节点排序失败:",e)}const d=[];for(const l of a){const a=l.original[o],c=[...s,a],h=r+1;l.depth=h;let f=l.formatted;const u={level:h,path:c,isLeaf:0===l.children.length,parent:t,childCount:l.children.length};n?f={...n(l.original,u),[i]:[]}:p&&(f={...p(l.original,u),[i]:[]}),f.__parentId=e.original[o],d.push(f),l.formatted=f,m.push({nodeInfo:l,formattedNode:f,depth:h,path:c})}t[i]=d;const c={level:r,path:s,isLeaf:0===d.length,childCount:d.length};n?(Object.assign(t,n(e.original,c)),t[i]=d):p&&(Object.assign(t,p(e.original,c)),t[i]=d)}if(f&&y.length>1)try{y.sort((e,t)=>{const n=e[o],r=t[o],i=g.get(n),s=g.get(r);return i&&s?f(i.original,s.original):0})}catch(e){console.warn("根节点排序失败:",e)}return performance.now(),process.memoryUsage?.(),y},exports.buildMinimalTree=function(e,t={}){const n={idKey:"id",parentKey:"parentId",childrenKey:"children",rootParentId:0,enableGhostNodes:!1,validateNodes:!0,maxDepth:1e3,enableCache:!1,...t};if(!Array.isArray(e)||0===e.length)return[];const o=new Map,r=[];for(const t of e){const e=t[n.idKey];n.validateNodes&&null==e?console.warn(`节点缺少ID字段 "${n.idKey}"，将被忽略:`,t):(o.has(e)&&console.warn(`发现重复ID "${e}"，后一个节点将覆盖前一个`),o.set(e,{...t,[n.childrenKey]:[]}))}const i=new Set;for(const t of e){const e=t[n.idKey],s=t[n.parentKey],a=o.get(e);if(!a)continue;if(i.has(e))continue;i.add(e);if(null==s||s===n.rootParentId)r.push(a);else{const t=o.get(s);if(t)t[n.childrenKey].push(a);else if(n.enableGhostNodes){const e={[n.idKey]:s,[n.childrenKey]:[a],__isGhost:!0};o.set(s,e),r.push(e)}else console.warn(`父节点 "${s}" 不存在，节点 "${e}" 将被作为根节点`),r.push(a)}}return r},exports.validateMinimalTree=function(e,t={}){const n=new Set,o=t.childrenKey||"children";function r(e,i){const s=e[t.idKey||"id"];if(n.has(s))return console.error(`发现循环引用，节点ID: ${s}`),!1;if(n.add(s),i>(t.maxDepth||1e3))return console.error(`树深度超过限制: ${i}`),!1;const a=e[o];if(Array.isArray(a))for(const e of a)if(!r(e,i+1))return!1;return n.delete(s),!0}try{for(const t of e)if(!r(t,1))return!1;return!0}catch(e){return console.error("树验证失败:",e),!1}};
//# sourceMappingURL=index.js.map
