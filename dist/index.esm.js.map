{"version":3,"file":"index.esm.js","sources":["../src/core/minimal.ts","../src/core/enhanced.ts","../src/builder/smart.ts","../src/plugins/index.ts","../src/plugins/cycle-detection.ts","../src/plugins/sorting.ts","../src/index.ts"],"sourcesContent":["import { TreeBuilderConfig } from './types';\n\n/**\n * 最小化树形构建器（对标 row-to-tree）\n * 时间复杂度: O(n)，空间复杂度: O(n)\n */\nexport function buildMinimalTree<T = any>(\n  list: T[],\n  options: TreeBuilderConfig<T> = {}\n): any[] {\n  // 合并配置\n  const config: Required<TreeBuilderConfig> = {\n    idKey: 'id',\n    parentKey: 'parentId',\n    childrenKey: 'children',\n    rootParentId: 0,\n    enableGhostNodes: false,\n    validateNodes: true,\n    maxDepth: 1000,\n    enableCache: false,\n    ...options\n  };\n\n  // 空列表检查\n  if (!Array.isArray(list) || list.length === 0) {\n    return [];\n  }\n\n  const map = new Map<string | number, any>();\n  const roots: any[] = [];\n\n  // 第一遍：创建所有节点\n  for (const item of list) {\n    const id = (item as any)[config.idKey];\n    \n    // 验证节点ID\n    if (config.validateNodes && (id === undefined || id === null)) {\n      console.warn(`节点缺少ID字段 \"${config.idKey}\"，将被忽略:`, item);\n      continue;\n    }\n\n    // 检查重复ID\n    if (map.has(id)) {\n      console.warn(`发现重复ID \"${id}\"，后一个节点将覆盖前一个`);\n    }\n\n    map.set(id, {\n      ...item,\n      [config.childrenKey]: []\n    });\n  }\n\n  // 第二遍：建立父子关系\n  const processedIds = new Set<string | number>();\n  for (const item of list) {\n    const id = (item as any)[config.idKey];\n    const parentId = (item as any)[config.parentKey];\n    \n    const node = map.get(id);\n    if (!node) continue;\n\n    // 如果这个ID已经处理过，跳过（避免重复ID被多次处理）\n    if (processedIds.has(id)) {\n      continue;\n    }\n    processedIds.add(id);\n\n    // 判断是否为根节点\n    const isRoot = parentId === null || \n                  parentId === undefined || \n                  parentId === config.rootParentId;\n\n    if (isRoot) {\n      roots.push(node);\n    } else {\n      const parent = map.get(parentId);\n      \n      if (parent) {\n        // 正常父子关系\n        parent[config.childrenKey].push(node);\n      } else if (config.enableGhostNodes) {\n        // 创建幽灵节点\n        const ghostNode = { \n          [config.idKey]: parentId, \n          [config.childrenKey]: [node],\n          __isGhost: true \n        };\n        map.set(parentId, ghostNode);\n        roots.push(ghostNode);\n      } else {\n        // 父节点不存在，作为根节点\n        console.warn(`父节点 \"${parentId}\" 不存在，节点 \"${id}\" 将被作为根节点`);\n        roots.push(node);\n      }\n    }\n  }\n\n  return roots;\n}\n\n/**\n * 验证最小树的有效性\n */\nexport function validateMinimalTree(tree: any[], config: TreeBuilderConfig = {}): boolean {\n  const visited = new Set<string | number>();\n  const childrenKey = config.childrenKey || 'children';\n  \n  function validateNode(node: any, depth: number): boolean {\n    const id = node[config.idKey || 'id'];\n    \n    // 检查循环引用\n    if (visited.has(id)) {\n      console.error(`发现循环引用，节点ID: ${id}`);\n      return false;\n    }\n    \n    visited.add(id);\n    \n    // 检查深度限制\n    if (depth > (config.maxDepth || 1000)) {\n      console.error(`树深度超过限制: ${depth}`);\n      return false;\n    }\n    \n    // 递归检查子节点\n    const children = node[childrenKey];\n    if (Array.isArray(children)) {\n      for (const child of children) {\n        if (!validateNode(child, depth + 1)) {\n          return false;\n        }\n      }\n    }\n    \n    visited.delete(id);\n    return true;\n  }\n  \n  try {\n    for (const node of tree) {\n      if (!validateNode(node, 1)) {\n        return false;\n      }\n    }\n    return true;\n  } catch (error) {\n    console.error('树验证失败:', error);\n    return false;\n  }\n}","import { EnhancedTreeConfig, NodeContext, BuildStats } from './types';\n\n/**\n * 增强树形构建器\n * 支持循环引用检测、节点排序、格式化等高级功能\n */\nexport function buildEnhancedTree<T = any, R = T>(\n  list: T[],\n  options: EnhancedTreeConfig<T> = {},\n  formatCallback?: (node: T, context: NodeContext) => R\n): R[] {\n  // 提取配置，分别处理每个属性\n  const idKey = options.idKey || 'id';\n  const parentKey = options.parentKey || 'parentId';\n  const childrenKey = options.childrenKey || 'children';\n  const rootParentId = options.rootParentId ?? 0;\n  const enableGhostNodes = options.enableGhostNodes || false;\n  const validateNodes = options.validateNodes !== false; // 默认为true\n  const maxDepth = options.maxDepth || 1000;\n  const detectCycles = options.detectCycles || false;\n  const onCycleDetected = options.onCycleDetected || ((node: T, path: (string | number)[]) => {\n    console.warn(`发现循环引用，路径: ${path.join(' -> ')}`);\n  });\n  const sortChildren = options.sortChildren;\n  const formatNode = options.formatNode;\n  const isRootNode = options.isRootNode;\n\n  // 性能监控\n  const startTime = performance.now();\n  const startMemory = process.memoryUsage?.()?.heapUsed || 0;\n  const stats: BuildStats = {\n    totalNodes: 0,\n    rootNodes: 0,\n    maxDepth: 0,\n    buildTime: 0,\n    memoryUsed: 0,\n    cyclesDetected: 0,\n    ghostNodesCreated: 0\n  };\n\n  // 空列表检查\n  if (!Array.isArray(list) || list.length === 0) {\n    return [];\n  }\n\n  // 节点映射表\n  const nodeMap = new Map<string | number, {\n    original: T;\n    formatted: any;\n    parentId: string | number | null;\n    children: any[];\n    depth: number;\n    isGhost?: boolean;\n  }>();\n\n  // 根节点列表\n  const roots: any[] = [];\n\n  // 第一步：收集所有节点\n  for (const item of list) {\n    const id = (item as any)[idKey];\n    const parentId = (item as any)[parentKey] ?? null;\n\n    // 验证节点\n    if (validateNodes && (id === undefined || id === null)) {\n      console.warn(`节点缺少ID字段 \"${idKey}\"，将被忽略:`, item);\n      continue;\n    }\n\n    // 检查自引用\n    if (id === parentId) {\n      if (detectCycles) {\n        onCycleDetected(item, [id]);\n        stats.cyclesDetected++;\n      }\n      continue;\n    }\n\n    // 创建格式化节点（如果需要）\n    const initialContext: NodeContext = {\n      level: 0,\n      path: [id],\n      isLeaf: true,\n      childCount: 0\n    };\n\n    let formattedNode: any;\n    if (formatCallback) {\n      formattedNode = formatCallback(item, initialContext);\n      formattedNode[childrenKey] = [];\n    } else if (formatNode) {\n      formattedNode = formatNode(item, initialContext);\n      formattedNode[childrenKey] = [];\n    } else {\n      formattedNode = {\n        ...item,\n        [childrenKey]: []\n      };\n    }\n\n    nodeMap.set(id, {\n      original: item,\n      formatted: formattedNode,\n      parentId,\n      children: [],\n      depth: 0\n    });\n  }\n\n  stats.totalNodes = nodeMap.size;\n\n  // 第二步：检测循环引用（如果需要）\n  if (detectCycles && nodeMap.size > 0) {\n    // 只处理自引用节点（parentId === id），其他情况交给后续处理\n    const nodesToDelete: Set<string | number> = new Set();\n    \n    for (const [id, nodeInfo] of nodeMap) {\n      if (nodeInfo.parentId === id) {\n        stats.cyclesDetected++;\n        onCycleDetected(nodeInfo.original, [id]);\n        nodesToDelete.add(id); // 标记自引用节点待删除\n      }\n    }\n    \n    // 执行删除操作\n    nodesToDelete.forEach(id => {\n      nodeMap.delete(id);\n    });\n  }\n\n  // 第三步：建立父子关系\n  for (const [id, nodeInfo] of nodeMap) {\n    // 跳过幽灵节点，因为它们已经作为根节点添加了\n    if (nodeInfo.isGhost) {\n      continue;\n    }\n    const { parentId } = nodeInfo;\n\n    // 判断是否为根节点\n    const isRoot = isRootNode ? \n      isRootNode(nodeInfo.original) : \n      (parentId === null || \n       parentId === undefined || \n       parentId === rootParentId);\n\n    if (isRoot) {\n      roots.push(nodeInfo.formatted);\n      nodeInfo.depth = 1;\n      stats.rootNodes++;\n    } else {\n      const parentInfo = nodeMap.get(parentId!);\n      if (parentInfo) {\n        // 父节点存在，正常挂载\n        parentInfo.children.push(nodeInfo);\n        nodeInfo.formatted.__parentId = parentId;\n      } else {\n        // 父节点不存在\n        if (enableGhostNodes) {\n          // 检查是否已经存在这个幽灵节点（在 nodeMap 或 roots 中）\n          const existingGhostNode = nodeMap.get(parentId!);\n          if (existingGhostNode) {\n            // 幽灵节点已存在，直接将当前节点添加到其子节点\n            existingGhostNode.children.push(nodeInfo);\n            nodeInfo.formatted.__parentId = parentId;\n            nodeInfo.depth = existingGhostNode.depth + 1;\n          } else {\n            // 创建新的幽灵节点\n            const ghostNode = {\n              [idKey]: parentId,\n              [childrenKey]: [nodeInfo.formatted],\n              __isGhost: true,\n              __parentId: null\n            };\n            \n            const ghostInfo = {\n              original: { [idKey]: parentId } as T,\n              formatted: ghostNode,\n              parentId: null,\n              children: [nodeInfo],\n              depth: 1,\n              isGhost: true\n            };\n            \n            nodeMap.set(parentId!, ghostInfo);\n            roots.push(ghostNode);\n            nodeInfo.formatted.__parentId = parentId;\n            nodeInfo.depth = 2;\n            stats.ghostNodesCreated++;\n            stats.rootNodes++;\n          }\n          /* // 创建幽灵节点\n          const ghostNode = {\n            [idKey]: parentId,\n            [childrenKey]: [nodeInfo.formatted],\n            __isGhost: true,\n            __parentId: null\n          };\n          \n          const ghostInfo = {\n            original: { [idKey]: parentId } as T,\n            formatted: ghostNode,\n            parentId: null,\n            children: [nodeInfo],\n            depth: 1\n          };\n          \n          nodeMap.set(parentId!, ghostInfo);\n          roots.push(ghostNode); // 幽灵节点作为根节点\n          nodeInfo.formatted.__parentId = parentId;\n          nodeInfo.depth = 2;\n          stats.ghostNodesCreated++;\n          stats.rootNodes++; */\n        } else {\n          // 不启用幽灵节点，将当前节点作为根节点\n          roots.push(nodeInfo.formatted);\n          nodeInfo.depth = 1;\n          stats.rootNodes++;\n        }\n      }\n    }\n  }\n\n  // 第四步：深度优先计算层级和路径\n  const stack: Array<{\n    nodeInfo: any;\n    formattedNode: any;\n    depth: number;\n    path: (string | number)[];\n  }> = [];\n\n  // 初始化栈\n  roots.forEach(rootNode => {\n    // 从nodeInfo中获取根节点ID，而不是从formattedNode中\n    // 遍历nodeMap，找到对应的nodeInfo\n    for (const [id, nodeInfo] of nodeMap) {\n      if (nodeInfo.formatted === rootNode) {\n        stack.push({\n          nodeInfo,\n          formattedNode: rootNode,\n          depth: 1,\n          path: [id]\n        });\n        break;\n      }\n    }\n  });\n\n  while (stack.length > 0) {\n    const { nodeInfo, formattedNode, depth, path } = stack.pop()!;\n    \n    // 更新最大深度\n    stats.maxDepth = Math.max(stats.maxDepth, depth);\n    \n    // 检查深度限制\n    if (depth > maxDepth) {\n      console.warn(`节点 \"${path.join(' -> ')}\" 深度超过限制: ${depth}`);\n      continue;\n    }\n\n    // 处理子节点\n    const childrenInfos = nodeInfo.children;\n    \n    // 子节点排序\n    if (sortChildren && childrenInfos.length > 0) {\n      try {\n        childrenInfos.sort((a: any, b: any) => \n          sortChildren(a.original, b.original)\n        );\n      } catch (error) {\n        console.warn('子节点排序失败:', error);\n      }\n    }\n\n    // 构建子节点\n    const children: any[] = [];\n    for (const childInfo of childrenInfos) {\n      const childId = childInfo.original[idKey];\n      const childPath = [...path, childId];\n      const childDepth = depth + 1;\n      \n      // 更新子节点深度\n      childInfo.depth = childDepth;\n      \n      // 创建或获取格式化节点\n      let childFormatted = childInfo.formatted;\n      \n      // 计算子节点上下文\n      const childContext: NodeContext = {\n        level: childDepth,\n        path: childPath,\n        isLeaf: childInfo.children.length === 0,\n        parent: formattedNode,\n        childCount: childInfo.children.length\n      };\n      \n      // 应用格式化回调\n      if (formatCallback) {\n        childFormatted = {\n          ...formatCallback(childInfo.original, childContext),\n          [childrenKey]: []\n        };\n      } else if (formatNode) {\n        childFormatted = {\n          ...formatNode(childInfo.original, childContext),\n          [childrenKey]: []\n        };\n      }\n      \n      // 设置父ID引用\n      childFormatted.__parentId = nodeInfo.original[idKey];\n      \n      children.push(childFormatted);\n      childInfo.formatted = childFormatted;\n      \n      // 继续处理子节点的子节点\n      stack.push({\n        nodeInfo: childInfo,\n        formattedNode: childFormatted,\n        depth: childDepth,\n        path: childPath\n      });\n    }\n    \n    // 更新当前节点的子节点列表\n    formattedNode[childrenKey] = children;\n    \n    // 更新当前节点的上下文信息\n    const currentContext: NodeContext = {\n      level: depth,\n      path,\n      isLeaf: children.length === 0,\n      childCount: children.length\n    };\n    \n    // 重新格式化当前节点（如果需要）\n    if (formatCallback) {\n      Object.assign(formattedNode, formatCallback(nodeInfo.original, currentContext));\n      formattedNode[childrenKey] = children; // 保持子节点引用\n    } else if (formatNode) {\n      Object.assign(formattedNode, formatNode(nodeInfo.original, currentContext));\n      formattedNode[childrenKey] = children;\n    }\n  }\n\n  // 第五步：根节点排序\n  if (sortChildren && roots.length > 1) {\n    try {\n      roots.sort((a, b) => {\n        const aId = a[idKey];\n        const bId = b[idKey];\n        const aInfo = nodeMap.get(aId);\n        const bInfo = nodeMap.get(bId);\n        \n        if (aInfo && bInfo) {\n          return sortChildren(aInfo.original, bInfo.original);\n        }\n        return 0;\n      });\n    } catch (error) {\n      console.warn('根节点排序失败:', error);\n    }\n  }\n\n  // 计算性能统计\n  const endTime = performance.now();\n  const endMemory = process.memoryUsage?.()?.heapUsed || 0;\n  \n  stats.buildTime = endTime - startTime;\n  stats.memoryUsed = (endMemory - startMemory) / (1024 * 1024); // 转换为MB\n\n  // 添加统计信息到根节点\n  if (roots.length > 0) {\n    (roots as any).__stats = stats;\n  }\n\n  return roots;\n}\n\n/**\n * 循环引用检测函数\n * 使用深度优先搜索检测有向图中的环\n */\nfunction detectCyclesInMap(\n  nodeMap: Map<string | number, any>,\n  idKey: string\n): (string | number)[][] {\n  const cycles: (string | number)[][] = [];\n  const visited = new Set<string | number>();\n  const recursionStack = new Set<string | number>();\n  const path: (string | number)[] = [];\n  \n  // 深度优先搜索检测环\n  function dfs(id: string | number) {\n    // 如果节点正在递归栈中，说明找到了环\n    if (recursionStack.has(id)) {\n      const cycleStartIndex = path.indexOf(id);\n      if (cycleStartIndex !== -1) {\n        cycles.push(path.slice(cycleStartIndex));\n      }\n      return;\n    }\n    \n    // 如果节点已经访问过，跳过\n    if (visited.has(id)) {\n      return;\n    }\n    \n    // 标记节点为已访问和在递归栈中\n    visited.add(id);\n    recursionStack.add(id);\n    path.push(id);\n    \n    // 获取节点的子节点\n    const nodeInfo = nodeMap.get(id);\n    if (nodeInfo) {\n      const parentId = nodeInfo.parentId;\n      // 遍历父节点（因为树结构中每个节点只有一个父节点）\n      if (parentId !== null && nodeMap.has(parentId) && id !== parentId) {\n        dfs(parentId);\n      }\n    }\n    \n    // 从递归栈和路径中移除节点\n    recursionStack.delete(id);\n    path.pop();\n  }\n  \n  // 遍历所有节点\n  nodeMap.forEach((nodeInfo, id) => {\n    if (!visited.has(id)) {\n      dfs(id);\n    }\n  });\n  \n  return cycles;\n}","import { TreeBuilderConfig, TreePlugin, BuildStats } from '../core/types';\nimport { buildMinimalTree } from '../core/minimal';\nimport { buildEnhancedTree } from '../core/enhanced';\n\n/**\n * 智能树形构建器\n * 根据数据特征自动选择最优构建策略\n */\nexport class SmartTreeBuilder<T = any> {\n  private plugins: TreePlugin<T>[] = [];\n  private config: TreeBuilderConfig<T>;\n  private cache = new Map<string, any>();\n  private stats: BuildStats[] = [];\n\n  constructor(config: TreeBuilderConfig<T> = {}) {\n    this.config = {\n      idKey: 'id',\n      parentKey: 'parentId',\n      childrenKey: 'children',\n      rootParentId: 0,\n      enableGhostNodes: false,\n      validateNodes: true,\n      maxDepth: 1000,\n      enableCache: false,\n      ...config\n    };\n  }\n\n  /**\n   * 注册插件\n   */\n  use(plugin: TreePlugin<T>): this {\n    this.plugins.push(plugin);\n    // 按优先级排序\n    this.plugins.sort((a, b) => (a.priority || 100) - (b.priority || 100));\n    return this;\n  }\n\n  /**\n   * 构建树形结构\n   */\n  build(list: T[]): any[] {\n    // 处理空输入\n    if (!list) {\n      return [];\n    }\n    const startTime = performance.now();\n    \n    // 生成缓存键\n    const cacheKey = this.generateCacheKey(list);\n    \n    // 检查缓存\n    if (this.config.enableCache && this.cache.has(cacheKey)) {\n      console.log('使用缓存结果');\n      const cached = this.cache.get(cacheKey);\n  \n      // 为缓存命中记录统计信息\n      const cacheStats: BuildStats = {\n        totalNodes: list.length,\n        rootNodes: cached?.length || 0,\n        maxDepth: this.calculateMaxDepth(cached || []),\n        buildTime: 0, // 缓存命中，构建时间为0\n        memoryUsed: 0,\n        cyclesDetected: 0,\n        ghostNodesCreated: 0,\n        cacheHit: true // 添加缓存命中标记\n      };\n      \n      this.stats.push(cacheStats);\n      return cached;\n    }\n\n    // 选择构建策略\n    const strategy = this.selectStrategy(list);\n    console.log(`选择构建策略: ${strategy.name}`);\n    \n    let tree: any[];\n    \n    // 应用前置插件\n    const beforeResult = this.applyBeforeBuild(list);\n    const processedList = beforeResult ? beforeResult : list;\n    \n    // 执行构建\n    switch (strategy.name) {\n      case 'minimal':\n        tree = buildMinimalTree(processedList, this.config);\n        break;\n      case 'enhanced':\n        tree = buildEnhancedTree(processedList, this.config as any);\n        break;\n      case 'incremental':\n        tree = this.buildIncremental(processedList);\n        break;\n      default:\n        tree = buildMinimalTree(processedList, this.config);\n    }\n    \n    // 应用后置插件\n    tree = this.applyAfterBuild(tree, list);\n    \n    // 更新统计信息\n    const endTime = performance.now();\n    const buildStats: BuildStats = {\n      totalNodes: list.length,\n      rootNodes: tree.length,\n      maxDepth: this.calculateMaxDepth(tree),\n      buildTime: endTime - startTime,\n      memoryUsed: this.getMemoryUsage(),\n      cyclesDetected: 0,\n      ghostNodesCreated: 0\n    };\n    \n    this.stats.push(buildStats);\n    \n    // 缓存结果\n    if (this.config.enableCache) {\n      this.cache.set(cacheKey, tree);\n    }\n    \n    // 添加统计信息\n    (tree as any).__stats = buildStats;\n    \n    return tree;\n  }\n\n  /**\n   * 获取构建统计信息\n   */\n  getStats(): BuildStats[] {\n    return this.stats;\n  }\n\n  /**\n   * 清除缓存\n   */\n  clearCache(): void {\n    this.cache.clear();\n  }\n\n  /**\n   * 重置构建器状态\n   */\n  reset(): void {\n    this.plugins = [];\n    this.cache.clear();\n    this.stats = [];\n  }\n\n  /**\n   * 生成缓存键\n   */\n  private generateCacheKey(list: T[]): string {\n    const configStr = JSON.stringify(this.config);\n  \n    // 处理 null 或 undefined 的情况\n    if (!list) {\n      return `${configStr}:null:0`;\n    }\n    \n    const listStr = JSON.stringify(list.slice(0, Math.min(10, list.length)));\n    return `${configStr}:${listStr}:${list.length}`;\n  }\n\n  /**\n   * 根据数据特征选择构建策略\n   */\n  private selectStrategy(list: T[]): { name: string; description: string } {\n    // 数据量小于1000，使用最小化构建\n    if (list.length < 1000) {\n      return { name: 'minimal', description: '最小化构建策略' };\n    }\n    \n    // 检查是否需要高级功能\n    const needsAdvanced = this.plugins.length > 0 || \n                         this.config.enableGhostNodes ||\n                         this.config.maxDepth !== 1000;\n    \n    if (needsAdvanced) {\n      return { name: 'enhanced', description: '增强构建策略' };\n    }\n    \n    // 数据量很大且结构简单，使用最小化构建\n    return { name: 'minimal', description: '最小化构建策略' };\n  }\n\n  /**\n   * 应用前置插件\n   */\n  private applyBeforeBuild(list: T[]): T[] | void {\n    let result: T[] = list;\n    \n    for (const plugin of this.plugins) {\n      if (plugin.onNodeCreated) {\n        // 创建节点时应用插件\n        result = result.map((item, index) => {\n          const context = {\n            level: 0,\n            path: [(item as any)[this.config.idKey || 'id']],\n            isLeaf: true,\n            childCount: 0\n          };\n          \n          plugin.onNodeCreated?.(item, context);\n          return item;\n        });\n      }\n    }\n    \n    return result;\n  }\n\n  /**\n   * 应用后置插件\n   */\n  private applyAfterBuild(tree: any[], originalList: T[]): any[] {\n    let result = tree;\n    \n    for (const plugin of this.plugins) {\n      if (plugin.onTreeBuilt) {\n        const pluginResult = plugin.onTreeBuilt(result, { originalList });\n        if (pluginResult) {\n          result = pluginResult;\n        }\n      }\n    }\n    \n    return result;\n  }\n\n  /**\n   * 增量构建（简化版）\n   */\n  private buildIncremental(list: T[]): any[] {\n    // 简化的增量构建实现\n    const tree = buildMinimalTree(list, this.config);\n    \n    // 应用增量优化\n    this.optimizeTreeStructure(tree);\n    \n    return tree;\n  }\n\n  /**\n   * 优化树结构\n   */\n  private optimizeTreeStructure(tree: any[]): void {\n    // 优化算法：扁平化深度嵌套\n    this.flattenDeepNesting(tree, this.config.maxDepth || 1000);\n  }\n\n  /**\n   * 扁平化深度嵌套\n   */\n  private flattenDeepNesting(tree: any[], maxDepth: number): void {\n    const childrenKey = this.config.childrenKey || 'children';\n    \n    function flatten(node: any, depth: number): any {\n      if (depth >= maxDepth && node[childrenKey]?.length > 0) {\n        // 将深层子节点提升为兄弟节点\n        const flattened = {\n          ...node,\n          [childrenKey]: []\n        };\n        \n        // 递归处理子节点\n        const processChildren = (children: any[], currentDepth: number) => {\n          for (const child of children) {\n            if (currentDepth >= maxDepth) {\n              // 提升为兄弟节点\n              tree.push(child);\n            } else {\n              flattened[childrenKey].push(child);\n            }\n            processChildren(child[childrenKey] || [], currentDepth + 1);\n          }\n        };\n        \n        processChildren(node[childrenKey] || [], depth);\n        return flattened;\n      }\n      \n      return node;\n    }\n    \n    for (let i = 0; i < tree.length; i++) {\n      tree[i] = flatten(tree[i], 1);\n    }\n  }\n\n  /**\n   * 计算树的最大深度\n   */\n  private calculateMaxDepth(tree: any[]): number {\n    const childrenKey = this.config.childrenKey || 'children';\n    let maxDepth = 0;\n    \n    function calculate(node: any, depth: number): void {\n      maxDepth = Math.max(maxDepth, depth);\n      \n      const children = node[childrenKey];\n      if (Array.isArray(children)) {\n        for (const child of children) {\n          calculate(child, depth + 1);\n        }\n      }\n    }\n    \n    for (const node of tree) {\n      calculate(node, 1);\n    }\n    \n    return maxDepth;\n  }\n\n  /**\n   * 获取内存使用情况\n   */\n  private getMemoryUsage(): number {\n    if (typeof process !== 'undefined' && process.memoryUsage) {\n      const usage = process.memoryUsage();\n      return usage.heapUsed / 1024 / 1024; // MB\n    }\n    return 0;\n  }\n}","import { TreePlugin, NodeContext } from '../core/types';\n\n/**\n * 插件管理器\n */\nexport class PluginManager<T = any> {\n  private plugins: Map<string, TreePlugin<T>> = new Map();\n  \n  /**\n   * 注册插件\n   */\n  register(plugin: TreePlugin<T>): void {\n    if (this.plugins.has(plugin.name)) {\n      console.warn(`插件 \"${plugin.name}\" 已存在，将被覆盖`);\n    }\n    this.plugins.set(plugin.name, plugin);\n  }\n  \n  /**\n   * 取消注册插件\n   */\n  unregister(pluginName: string): boolean {\n    return this.plugins.delete(pluginName);\n  }\n  \n  /**\n   * 获取插件\n   */\n  getPlugin(pluginName: string): TreePlugin<T> | undefined {\n    return this.plugins.get(pluginName);\n  }\n  \n  /**\n   * 获取所有插件\n   */\n  getAllPlugins(): TreePlugin<T>[] {\n    return Array.from(this.plugins.values())\n      .sort((a, b) => (a.priority || 100) - (b.priority || 100));\n  }\n  \n  /**\n   * 应用节点创建钩子\n   */\n  applyNodeCreated(node: T, context: NodeContext): T {\n    let result = node;\n    \n    for (const plugin of this.getAllPlugins()) {\n      if (plugin.onNodeCreated) {\n        plugin.onNodeCreated(result, context);\n      }\n    }\n    \n    return result;\n  }\n  \n  /**\n   * 应用节点链接钩子\n   */\n  applyNodeLinked(parent: T, child: T, context: NodeContext): boolean {\n    let allowLink = true;\n    \n    for (const plugin of this.getAllPlugins()) {\n      if (plugin.onNodeLinked) {\n        const result = plugin.onNodeLinked(parent, child, context);\n        if (result === false) {\n          allowLink = false;\n          break;\n        }\n      }\n    }\n    \n    return allowLink;\n  }\n  \n  /**\n   * 应用树构建完成钩子\n   */\n  applyTreeBuilt(tree: T[], context: { originalList: T[] }): T[] {\n    let result = tree;\n    \n    for (const plugin of this.getAllPlugins()) {\n      if (plugin.onTreeBuilt) {\n        const pluginResult = plugin.onTreeBuilt(result, context);\n        if (pluginResult) {\n          result = pluginResult;\n        }\n      }\n    }\n    \n    return result;\n  }\n  \n  /**\n   * 清除所有插件\n   */\n  clear(): void {\n    this.plugins.clear();\n  }\n  \n  /**\n   * 获取插件数量\n   */\n  get count(): number {\n    return this.plugins.size;\n  }\n}","import { TreePlugin, NodeContext } from '../core/types';\n\n/**\n * 循环引用检测插件\n */\nexport function createCycleDetectionPlugin(options: {\n  /** 是否抛出错误，默认 false */\n  throwOnCycle?: boolean;\n  /** 修复循环引用的策略，默认 'remove' */\n  fixStrategy?: 'remove' | 'break' | 'ignore';\n} = {}): TreePlugin {\n  const config = {\n    throwOnCycle: false,\n    fixStrategy: 'remove' as const,\n    ...options\n  };\n  \n  const visited = new Set<string | number>();\n  const recursionStack = new Set<string | number>();\n  const cycles: (string | number)[][] = [];\n  \n  const removeCycles = (tree: any[]) => {\n    const nodesToRemove = new Set<string | number>();\n    \n    cycles.forEach(cycle => {\n      // 移除循环中的最后一个节点（通常是问题节点）\n      const nodeToRemove = cycle[cycle.length - 1];\n      nodesToRemove.add(nodeToRemove);\n    });\n    \n    removeNodes(tree, nodesToRemove);\n  };\n  \n  const breakCycles = (tree: any[]) => {\n    cycles.forEach(cycle => {\n      // 断开循环中的最后一条边\n      const parentId = cycle[cycle.length - 2];\n      const childId = cycle[cycle.length - 1];\n      \n      breakLink(tree, parentId, childId);\n    });\n  };\n  \n  const removeNodes = (tree: any[], nodesToRemove: Set<string | number>) => {\n    function removeFromTree(nodes: any[]): any[] {\n      return nodes.filter(node => {\n        if (nodesToRemove.has(node.id)) {\n          return false;\n        }\n        \n        if (node.children && node.children.length > 0) {\n          node.children = removeFromTree(node.children);\n        }\n        \n        return true;\n      });\n    }\n    \n    const filteredTree = removeFromTree(tree);\n    tree.length = 0;\n    tree.push(...filteredTree);\n  };\n  \n  const breakLink = (tree: any[], parentId: string | number, childId: string | number) => {\n    function findAndBreak(nodes: any[]): boolean {\n      for (let i = 0; i < nodes.length; i++) {\n        const node = nodes[i];\n        \n        if (node.id === parentId) {\n          // 找到父节点，移除子节点\n          if (node.children) {\n            const childIndex = node.children.findIndex((child: any) => child.id === childId);\n            if (childIndex !== -1) {\n              node.children.splice(childIndex, 1);\n              console.log(`已断开链接: ${parentId} -> ${childId}`);\n              return true;\n            }\n          }\n        }\n        \n        if (node.children && node.children.length > 0) {\n          if (findAndBreak(node.children)) {\n            return true;\n          }\n        }\n      }\n      \n      return false;\n    }\n    \n    findAndBreak(tree);\n  };\n  \n  return {\n    name: 'cycle-detection',\n    priority: 10, // 高优先级，最先执行\n    \n    onNodeLinked(parent: any, child: any, context: NodeContext): boolean {\n      const parentId = parent.id;\n      const childId = child.id;\n      \n      // 检查直接循环引用\n      if (parentId === childId) {\n        console.error(`发现自循环引用: ${parentId} -> ${childId}`);\n        \n        if (config.throwOnCycle) {\n          throw new Error(`循环引用: ${parentId} -> ${childId}`);\n        }\n        \n        cycles.push([parentId, childId]);\n        return config.fixStrategy === 'remove';\n      }\n      \n      // 检查间接循环引用\n      recursionStack.add(parentId);\n      \n      if (recursionStack.has(childId)) {\n        // 发现循环引用\n        const cyclePath = Array.from(recursionStack);\n        const cycleStart = cyclePath.indexOf(childId);\n        const cycle = cyclePath.slice(cycleStart);\n        cycle.push(childId);\n        \n        console.error(`发现循环引用: ${cycle.join(' -> ')}`);\n        cycles.push(cycle);\n        \n        if (config.throwOnCycle) {\n          throw new Error(`循环引用: ${cycle.join(' -> ')}`);\n        }\n        \n        recursionStack.delete(parentId);\n        return config.fixStrategy === 'remove';\n      }\n      \n      recursionStack.delete(parentId);\n      return true;\n    },\n    \n    onTreeBuilt(tree: any[]): void {\n      if (cycles.length > 0) {\n        console.warn(`检测到 ${cycles.length} 个循环引用`);\n        \n        if (config.fixStrategy === 'remove') {\n          removeCycles(tree);\n        } else if (config.fixStrategy === 'break') {\n          breakCycles(tree);\n        }\n      }\n      \n      // 清理状态\n      visited.clear();\n      recursionStack.clear();\n    }\n  };\n}\n\n/**\n * 创建拓扑排序检测器（更高效的循环检测）\n */\nexport function createTopologicalDetector(): TreePlugin {\n  const adjacency = new Map<string | number, Set<string | number>>();\n  const inDegree = new Map<string | number, number>();\n  \n  return {\n    name: 'topological-detector',\n    priority: 5,\n    \n    onNodeLinked(parent: any, child: any): void {\n      const parentId = parent.id;\n      const childId = child.id;\n      \n      // 初始化数据结构\n      if (!adjacency.has(parentId)) {\n        adjacency.set(parentId, new Set());\n      }\n      if (!inDegree.has(childId)) {\n        inDegree.set(childId, 0);\n      }\n      if (!inDegree.has(parentId)) {\n        inDegree.set(parentId, 0);\n      }\n      \n      // 添加边\n      adjacency.get(parentId)!.add(childId);\n      inDegree.set(childId, (inDegree.get(childId) || 0) + 1);\n    },\n    \n    onTreeBuilt(): void {\n      // 使用Kahn算法检测环\n      const queue: (string | number)[] = [];\n      const result: (string | number)[] = [];\n      \n      // 入度为0的节点入队\n      inDegree.forEach((degree, id) => {\n        if (degree === 0) {\n          queue.push(id);\n        }\n      });\n      \n      // 处理队列\n      while (queue.length > 0) {\n        const current = queue.shift()!;\n        result.push(current);\n        \n        const neighbors = adjacency.get(current);\n        if (neighbors) {\n          neighbors.forEach(neighbor => {\n            const newDegree = (inDegree.get(neighbor) || 1) - 1;\n            inDegree.set(neighbor, newDegree);\n            \n            if (newDegree === 0) {\n              queue.push(neighbor);\n            }\n          });\n        }\n      }\n      \n      // 检查是否有环\n      if (result.length !== adjacency.size) {\n        console.error(`检测到循环引用，拓扑排序失败，共有 ${adjacency.size} 个节点，排序了 ${result.length} 个`);\n        \n        // 找出环中的节点\n        const inCycle = new Set<string | number>();\n        inDegree.forEach((degree, id) => {\n          if (degree > 0) {\n            inCycle.add(id);\n          }\n        });\n        \n        console.error(`环中的节点: ${Array.from(inCycle).join(', ')}`);\n      }\n      \n      // 清理状态\n      adjacency.clear();\n      inDegree.clear();\n    }\n  };\n}","import { TreePlugin } from '../core/types';\n\n/**\n * 树节点排序插件\n */\nexport function createSortingPlugin(\n  sortFn: (a: any, b: any) => number,\n  options: {\n    /** 排序范围：'all' | 'root' | 'children'，默认 'all' */\n    scope?: 'all' | 'root' | 'children';\n    /** 是否递归排序子节点，默认 true */\n    recursive?: boolean;\n    /** 排序时机：'during' | 'after'，默认 'after' */\n    timing?: 'during' | 'after';\n  } = {}\n): TreePlugin {\n  const config = {\n    scope: 'all' as const,\n    recursive: true,\n    timing: 'after' as const,\n    ...options\n  };\n  \n  const plugin: TreePlugin = {\n    name: 'sorting',\n    priority: 50,\n    \n    onTreeBuilt(tree: any[]): any[] {\n      if (config.timing === 'after') {\n        return sortTree(tree, sortFn, config);\n      }\n      return tree;\n    },\n    \n    onNodeLinked(parent: any, child: any): void {\n      if (config.timing === 'during' && config.scope !== 'root') {\n        // 在链接时排序子节点\n        if (parent.children && Array.isArray(parent.children)) {\n          try {\n            parent.children.sort(sortFn);\n          } catch (error) {\n            console.warn('节点排序失败:', error);\n          }\n        }\n      }\n    }\n  };\n  \n  return plugin;\n}\n\n/**\n * 排序整棵树\n */\nfunction sortTree(\n  tree: any[],\n  sortFn: (a: any, b: any) => number,\n  config: { scope: string; recursive: boolean }\n): any[] {\n  if (!tree || !Array.isArray(tree) || tree.length === 0) {\n    return tree;\n  }\n  \n  let result = [...tree];\n  \n  try {\n    // 排序根节点\n    if (config.scope === 'all' || config.scope === 'root') {\n      result.sort(sortFn);\n    }\n    \n    // 递归排序子节点\n    if (config.recursive && (config.scope === 'all' || config.scope === 'children')) {\n      for (const node of result) {\n        if (node.children && Array.isArray(node.children) && node.children.length > 0) {\n          node.children = sortTree(node.children, sortFn, config);\n        }\n      }\n    }\n  } catch (error) {\n    console.error('树排序失败:', error);\n  }\n  \n  return result;\n}\n\n/**\n * 创建多级排序插件\n */\nexport function createMultiLevelSorting(\n  sortRules: Array<{\n    key: string;\n    order: 'asc' | 'desc';\n    type?: 'string' | 'number' | 'date';\n  }>\n): TreePlugin {\n  const sortFn = createMultiLevelSortFn(sortRules);\n  \n  return createSortingPlugin(sortFn, {\n    scope: 'all',\n    recursive: true,\n    timing: 'after'\n  });\n}\n\n/**\n * 创建多级排序函数\n */\nfunction createMultiLevelSortFn(\n  sortRules: Array<{\n    key: string;\n    order: 'asc' | 'desc';\n    type?: 'string' | 'number' | 'date';\n  }>\n): (a: any, b: any) => number {\n  return (a: any, b: any): number => {\n    for (const rule of sortRules) {\n      const aValue = a[rule.key];\n      const bValue = b[rule.key];\n      \n      let comparison = 0;\n      \n      // 根据类型进行比较\n      if (rule.type === 'number') {\n        const aNum = Number(aValue) || 0;\n        const bNum = Number(bValue) || 0;\n        comparison = aNum - bNum;\n      } else if (rule.type === 'date') {\n        const aDate = aValue ? new Date(aValue).getTime() : 0;\n        const bDate = bValue ? new Date(bValue).getTime() : 0;\n        comparison = aDate - bDate;\n      } else {\n        // 字符串比较\n        const aStr = String(aValue || '');\n        const bStr = String(bValue || '');\n        comparison = aStr.localeCompare(bStr);\n      }\n      \n      // 应用排序方向\n      if (rule.order === 'desc') {\n        comparison = -comparison;\n      }\n      \n      if (comparison !== 0) {\n        return comparison;\n      }\n    }\n    \n    return 0;\n  };\n}","import { SmartTreeBuilder } from './builder/smart';\nimport { buildEnhancedTree } from './core/enhanced';\nimport { buildMinimalTree } from './core/minimal';\nimport { EnhancedTreeConfig, NodeContext, TreeBuilderConfig, TreePlugin } from './core/types';\n\n// 导出核心功能\nexport { buildMinimalTree } from './core/minimal';\nexport { buildEnhancedTree } from './core/enhanced';\nexport { validateMinimalTree } from './core/minimal';\n\n// 导出构建器\nexport { SmartTreeBuilder } from './builder/smart';\n\n// 导出插件\nexport { PluginManager } from './plugins';\nexport { createCycleDetectionPlugin, createTopologicalDetector } from './plugins/cycle-detection';\nexport { createSortingPlugin, createMultiLevelSorting } from './plugins/sorting';\n\n// 导出类型\nexport type {\n  TreeBuilderConfig,\n  EnhancedTreeConfig,\n  NodeContext,\n  TreePlugin,\n  BuildStats\n} from './core/types';\n\n/**\n * 快捷函数：创建树形结构（自动选择策略）\n */\nexport function createTree<T = any>(\n  list: T[],\n  options: TreeBuilderConfig<T> = {}\n): any[] {\n  // 简单策略：根据数据量选择算法\n  if (list.length < 1000) {\n    return buildMinimalTree(list, options);\n  }\n  \n  // 大数据量使用增强构建\n  return buildEnhancedTree(list, options as any);\n}\n\n/**\n * 创建高级树形构建器\n */\nexport function createAdvancedTree<T = any, R = T>(\n  list: T[],\n  options: EnhancedTreeConfig<T> = {},\n  formatCallback?: (node: T, context: NodeContext) => R\n): R[] {\n  return buildEnhancedTree(list, options, formatCallback);\n}\n\n/**\n * 创建带插件的树形构建器\n */\nexport function createPluginTreeBuilder<T = any>(\n  plugins: TreePlugin<T>[] = [],\n  config: TreeBuilderConfig<T> = {}\n): SmartTreeBuilder<T> {\n  const builder = new SmartTreeBuilder<T>(config);\n  \n  plugins.forEach(plugin => {\n    builder.use(plugin);\n  });\n  \n  return builder;\n}\n\n// 版本信息\nexport const VERSION = '1.0.0';\nexport const AUTHOR = 'Tree Formatter Library';\nexport const DESCRIPTION = '高性能、模块化的树形结构构建库';"],"names":["buildMinimalTree","list","options","config","idKey","parentKey","childrenKey","rootParentId","enableGhostNodes","validateNodes","maxDepth","enableCache","Array","isArray","length","map","Map","roots","item","id","console","warn","has","set","processedIds","Set","parentId","node","get","add","push","parent","ghostNode","__isGhost","validateMinimalTree","tree","visited","validateNode","depth","error","children","child","delete","buildEnhancedTree","formatCallback","detectCycles","onCycleDetected","path","join","sortChildren","formatNode","isRootNode","startTime","performance","now","startMemory","process","memoryUsage","heapUsed","stats","totalNodes","rootNodes","buildTime","memoryUsed","cyclesDetected","ghostNodesCreated","nodeMap","initialContext","level","isLeaf","childCount","formattedNode","original","formatted","size","nodesToDelete","nodeInfo","forEach","isGhost","parentInfo","__parentId","existingGhostNode","ghostInfo","stack","rootNode","pop","Math","max","childrenInfos","sort","a","b","childInfo","childId","childPath","childDepth","childFormatted","childContext","currentContext","Object","assign","aId","bId","aInfo","bInfo","endTime","endMemory","__stats","SmartTreeBuilder","constructor","this","plugins","cache","use","plugin","priority","build","cacheKey","generateCacheKey","log","cached","cacheStats","calculateMaxDepth","cacheHit","strategy","selectStrategy","name","beforeResult","applyBeforeBuild","processedList","buildIncremental","applyAfterBuild","buildStats","getMemoryUsage","getStats","clearCache","clear","reset","configStr","JSON","stringify","slice","min","description","result","onNodeCreated","index","context","originalList","onTreeBuilt","pluginResult","optimizeTreeStructure","flattenDeepNesting","flatten","flattened","processChildren","currentDepth","i","calculate","PluginManager","register","unregister","pluginName","getPlugin","getAllPlugins","from","values","applyNodeCreated","applyNodeLinked","allowLink","onNodeLinked","applyTreeBuilt","count","createCycleDetectionPlugin","throwOnCycle","fixStrategy","recursionStack","cycles","removeNodes","nodesToRemove","filteredTree","removeFromTree","nodes","filter","breakLink","findAndBreak","childIndex","findIndex","splice","Error","cyclePath","cycleStart","indexOf","cycle","nodeToRemove","removeCycles","breakCycles","createTopologicalDetector","adjacency","inDegree","queue","degree","current","shift","neighbors","neighbor","newDegree","inCycle","createSortingPlugin","sortFn","scope","recursive","timing","sortTree","createMultiLevelSorting","sortRules","rule","aValue","key","bValue","comparison","type","Number","Date","getTime","aStr","String","bStr","localeCompare","order","createMultiLevelSortFn","createTree","createAdvancedTree","createPluginTreeBuilder","builder","VERSION","AUTHOR","DESCRIPTION"],"mappings":"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"}