function e(e,t={}){const n={idKey:"id",parentKey:"parentId",childrenKey:"children",rootParentId:0,enableGhostNodes:!1,validateNodes:!0,maxDepth:1e3,enableCache:!1,...t};if(!Array.isArray(e)||0===e.length)return[];const s=new Map,o=[];for(const t of e){const e=t[n.idKey];n.validateNodes&&null==e?console.warn(`节点缺少ID字段 "${n.idKey}"，将被忽略:`,t):(s.has(e)&&console.warn(`发现重复ID "${e}"，后一个节点将覆盖前一个`),s.set(e,{...t,[n.childrenKey]:[]}))}const i=new Set;for(const t of e){const e=t[n.idKey],r=t[n.parentKey],c=s.get(e);if(!c)continue;if(i.has(e))continue;i.add(e);if(null==r||r===n.rootParentId)o.push(c);else{const t=s.get(r);if(t)t[n.childrenKey].push(c);else if(n.enableGhostNodes){const e={[n.idKey]:r,[n.childrenKey]:[c],__isGhost:!0};s.set(r,e),o.push(e)}else console.warn(`父节点 "${r}" 不存在，节点 "${e}" 将被作为根节点`),o.push(c)}}return o}function t(e,t={},n){const s=t.idKey||"id",o=t.parentKey||"parentId",i=t.childrenKey||"children",r=t.rootParentId??0,c=t.enableGhostNodes||!1,a=!1!==t.validateNodes,h=t.maxDepth||1e3,d=t.detectCycles||!1,l=t.onCycleDetected||((e,t)=>{console.warn(`发现循环引用，路径: ${t.join(" -> ")}`)}),p=t.sortChildren,f=t.formatNode,u=t.isRootNode,g=performance.now(),y=process.memoryUsage?.()?.heapUsed||0,m={totalNodes:0,rootNodes:0,maxDepth:0,buildTime:0,memoryUsed:0,cyclesDetected:0,ghostNodesCreated:0};if(!Array.isArray(e)||0===e.length)return[];const N=new Map,K=[];for(const t of e){const e=t[s],r=t[o]??null;if(a&&null==e){console.warn(`节点缺少ID字段 "${s}"，将被忽略:`,t);continue}if(e===r){d&&(l(t,[e]),m.cyclesDetected++);continue}const c={level:0,path:[e],isLeaf:!0,childCount:0};let h;n?(h=n(t,c),h[i]=[]):f?(h=f(t,c),h[i]=[]):h={...t,[i]:[]},N.set(e,{original:t,formatted:h,parentId:r,children:[],depth:0})}if(m.totalNodes=N.size,d&&N.size>0){const e=new Set;for(const[t,n]of N)n.parentId===t&&(m.cyclesDetected++,l(n.original,[t]),e.add(t));e.forEach(e=>{N.delete(e)})}for(const[e,t]of N){if(t.isGhost)continue;const{parentId:e}=t;if(u?u(t.original):null==e||e===r)K.push(t.formatted),t.depth=1,m.rootNodes++;else{const n=N.get(e);if(n)n.children.push(t),t.formatted.__parentId=e;else if(c){const n=N.get(e);if(n)n.children.push(t),t.formatted.__parentId=e,t.depth=n.depth+1;else{const n={[s]:e,[i]:[t.formatted],__isGhost:!0,__parentId:null},o={original:{[s]:e},formatted:n,parentId:null,children:[t],depth:1,isGhost:!0};N.set(e,o),K.push(n),t.formatted.__parentId=e,t.depth=2,m.ghostNodesCreated++,m.rootNodes++}}else K.push(t.formatted),t.depth=1,m.rootNodes++}}const I=[];for(K.forEach(e=>{for(const[t,n]of N)if(n.formatted===e){I.push({nodeInfo:n,formattedNode:e,depth:1,path:[t]});break}});I.length>0;){const{nodeInfo:e,formattedNode:t,depth:o,path:r}=I.pop();if(m.maxDepth=Math.max(m.maxDepth,o),o>h){console.warn(`节点 "${r.join(" -> ")}" 深度超过限制: ${o}`);continue}const c=e.children;if(p&&c.length>0)try{c.sort((e,t)=>p(e.original,t.original))}catch(e){console.warn("子节点排序失败:",e)}const a=[];for(const h of c){const c=h.original[s],d=[...r,c],l=o+1;h.depth=l;let p=h.formatted;const u={level:l,path:d,isLeaf:0===h.children.length,parent:t,childCount:h.children.length};n?p={...n(h.original,u),[i]:[]}:f&&(p={...f(h.original,u),[i]:[]}),p.__parentId=e.original[s],a.push(p),h.formatted=p,I.push({nodeInfo:h,formattedNode:p,depth:l,path:d})}t[i]=a;const d={level:o,path:r,isLeaf:0===a.length,childCount:a.length};n?(Object.assign(t,n(e.original,d)),t[i]=a):f&&(Object.assign(t,f(e.original,d)),t[i]=a)}if(p&&K.length>1)try{K.sort((e,t)=>{const n=e[s],o=t[s],i=N.get(n),r=N.get(o);return i&&r?p(i.original,r.original):0})}catch(e){console.warn("根节点排序失败:",e)}const w=performance.now(),b=process.memoryUsage?.()?.heapUsed||0;return m.buildTime=w-g,m.memoryUsed=(b-y)/1048576,K.length>0&&(K.__stats=m),K}class n{constructor(e={}){this.plugins=[],this.cache=new Map,this.stats=[],this.config={idKey:"id",parentKey:"parentId",childrenKey:"children",rootParentId:0,enableGhostNodes:!1,validateNodes:!0,maxDepth:1e3,enableCache:!1,...e}}use(e){return this.plugins.push(e),this.plugins.sort((e,t)=>(e.priority||100)-(t.priority||100)),this}build(n){if(!n)return[];const s=performance.now(),o=this.generateCacheKey(n);if(this.config.enableCache&&this.cache.has(o)){console.log("使用缓存结果");const e=this.cache.get(o),t={totalNodes:n.length,rootNodes:e?.length||0,maxDepth:this.calculateMaxDepth(e||[]),buildTime:0,memoryUsed:0,cyclesDetected:0,ghostNodesCreated:0,cacheHit:!0};return this.stats.push(t),e}const i=this.selectStrategy(n);let r;console.log(`选择构建策略: ${i.name}`);const c=this.applyBeforeBuild(n),a=c||n;switch(i.name){case"minimal":default:r=e(a,this.config);break;case"enhanced":r=t(a,this.config);break;case"incremental":r=this.buildIncremental(a)}r=this.applyAfterBuild(r,n);const h=performance.now(),d={totalNodes:n.length,rootNodes:r.length,maxDepth:this.calculateMaxDepth(r),buildTime:h-s,memoryUsed:this.getMemoryUsage(),cyclesDetected:0,ghostNodesCreated:0};return this.stats.push(d),this.config.enableCache&&this.cache.set(o,r),r.__stats=d,r}getStats(){return this.stats}clearCache(){this.cache.clear()}reset(){this.plugins=[],this.cache.clear(),this.stats=[]}generateCacheKey(e){const t=JSON.stringify(this.config);if(!e)return`${t}:null:0`;return`${t}:${JSON.stringify(e.slice(0,Math.min(10,e.length)))}:${e.length}`}selectStrategy(e){if(e.length<1e3)return{name:"minimal",description:"最小化构建策略"};return this.plugins.length>0||this.config.enableGhostNodes||1e3!==this.config.maxDepth?{name:"enhanced",description:"增强构建策略"}:{name:"minimal",description:"最小化构建策略"}}applyBeforeBuild(e){let t=e;for(const e of this.plugins)e.onNodeCreated&&(t=t.map((t,n)=>{const s={level:0,path:[t[this.config.idKey||"id"]],isLeaf:!0,childCount:0};return e.onNodeCreated?.(t,s),t}));return t}applyAfterBuild(e,t){let n=e;for(const e of this.plugins)if(e.onTreeBuilt){const s=e.onTreeBuilt(n,{originalList:t});s&&(n=s)}return n}buildIncremental(t){const n=e(t,this.config);return this.optimizeTreeStructure(n),n}optimizeTreeStructure(e){this.flattenDeepNesting(e,this.config.maxDepth||1e3)}flattenDeepNesting(e,t){const n=this.config.childrenKey||"children";function s(s,o){if(o>=t&&s[n]?.length>0){const i={...s,[n]:[]},r=(s,o)=>{for(const c of s)o>=t?e.push(c):i[n].push(c),r(c[n]||[],o+1)};return r(s[n]||[],o),i}return s}for(let t=0;t<e.length;t++)e[t]=s(e[t],1)}calculateMaxDepth(e){const t=this.config.childrenKey||"children";let n=0;function s(e,o){n=Math.max(n,o);const i=e[t];if(Array.isArray(i))for(const e of i)s(e,o+1)}for(const t of e)s(t,1);return n}getMemoryUsage(){if("undefined"!=typeof process&&process.memoryUsage){return process.memoryUsage().heapUsed/1024/1024}return 0}}class s{constructor(e={}){this.tree=[],this.nodeMap=new Map,this.config={idKey:"id",parentKey:"parentId",childrenKey:"children",rootParentId:0,enableGhostNodes:!1,validateNodes:!0,maxDepth:1e3,enableCache:!1,...e}}addNode(e){const t=e[this.config.idKey],n=e[this.config.parentKey]??null;if(this.nodeMap.has(t))return console.warn(`节点 ${t} 已存在，将更新该节点`),this.updateNode(t,e);const s={...e,[this.config.childrenKey]:[]};this.nodeMap.set(t,s);if(null==n||n===this.config.rootParentId||!this.nodeMap.has(n))this.tree.push(s);else{const e=this.nodeMap.get(n);if(e)e[this.config.childrenKey].push(s);else if(this.config.enableGhostNodes){const e={[this.config.idKey]:n,[this.config.childrenKey]:[s],__isGhost:!0};this.nodeMap.set(n,e),this.tree.push(e)}else this.tree.push(s)}return this}addNodes(e){return e.forEach(e=>this.addNode(e)),this}removeNode(e){const t=this.nodeMap.get(e);if(!t)return console.warn(`节点 ${e} 不存在`),this;const n=t.__parentId;if(n){const t=this.nodeMap.get(n);if(t&&t[this.config.childrenKey]){const n=t[this.config.childrenKey].findIndex(t=>t[this.config.idKey]===e);-1!==n&&t[this.config.childrenKey].splice(n,1)}}else{const t=this.tree.findIndex(t=>t[this.config.idKey]===e);-1!==t&&this.tree.splice(t,1)}const s=e=>{e[this.config.childrenKey]&&e[this.config.childrenKey].forEach(e=>{const t=e[this.config.idKey];this.nodeMap.delete(t),s(e)})};return s(t),this.nodeMap.delete(e),this}updateNode(e,t){const n=this.nodeMap.get(e);if(!n)return console.warn(`节点 ${e} 不存在，将尝试添加`),this.addNode({[this.config.idKey]:e,...t});Object.assign(n,t);const s=t[this.config.parentKey];return void 0!==s&&s!==n.__parentId?(this.removeNode(e),this.addNode({...n,...t})):this}findNode(e){return this.nodeMap.get(e)}getTree(){return this.tree}reset(){return this.tree=[],this.nodeMap.clear(),this}getNodeCount(){return this.nodeMap.size}getRootCount(){return this.tree.length}}class o{constructor(){this.name="minimal",this.description="最小化构建策略（对标 row-to-tree）"}build(t,n){return e(t,n)}}class i{constructor(){this.name="enhanced",this.description="增强构建策略（支持循环检测、排序等）"}build(e,n){return t(e,n)}}class r{constructor(){this.name="recursive",this.description="递归构建策略（适合深度嵌套）"}build(e,t){const n=t.idKey||"id",s=t.parentKey||"parentId",o=t.childrenKey||"children",i=t.rootParentId??0,r=new Map;e.forEach(e=>{const t=e[n];null!=t&&r.set(t,{...e,[o]:[]})});const c=(t=i)=>{const a=[];return e.forEach(e=>{const i=e[n];if(e[s]===t){const e=r.get(i);if(e){const t=c(i);e[o]=t,a.push(e)}}}),a};return c()}}class c{static selectStrategy(e,t={}){const n=e.length,s=t.enableGhostNodes||t.detectCycles||t.sortChildren;return n<1e3&&!s?new o:n>=1e3||s?new i:new o}static getAllStrategies(){return[new o,new i,new r]}}export{i as EnhancedStrategy,s as IncrementalTreeBuilder,o as MinimalStrategy,r as RecursiveStrategy,n as SmartTreeBuilder,c as StrategyFactory};
//# sourceMappingURL=index.esm.js.map
