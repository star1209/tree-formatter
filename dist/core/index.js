"use strict";exports.buildEnhancedTree=function(e,t={},o){const n=t.idKey||"id",r=t.parentKey||"parentId",s=t.childrenKey||"children",i=t.rootParentId??0,a=t.enableGhostNodes||!1,d=!1!==t.validateNodes,c=t.maxDepth||1e3,l=t.detectCycles||!1,h=t.onCycleDetected||((e,t)=>{console.warn(`发现循环引用，路径: ${t.join(" -> ")}`)}),f=t.sortChildren,p=t.formatNode;t.isRootNode;const u=performance.now(),g=process.memoryUsage?.()?.heapUsed||0,m={totalNodes:0,rootNodes:0,maxDepth:0,buildTime:0,memoryUsed:0,cyclesDetected:0,ghostNodesCreated:0};if(!Array.isArray(e)||0===e.length)return[];const y=new Map,I=[];for(const t of e){const e=t[n],i=t[r]??null;if(d&&null==e){console.warn(`节点缺少ID字段 "${n}"，将被忽略:`,t);continue}if(e===i){l&&(h(t,[e]),m.cyclesDetected++);continue}const a={level:0,path:[e],isLeaf:!0,childCount:0};let c;o?(c=o(t,a),c[s]=[]):p?(c=p(t,a),c[s]=[]):c={...t,[s]:[]},y.set(e,{original:t,formatted:c,parentId:i,children:[],depth:0})}if(m.totalNodes=y.size,l&&y.size>0){!function(e){const t=[],o=new Set,n=new Set,r=[];function s(i){if(n.has(i)){const e=r.indexOf(i);return void(-1!==e&&t.push(r.slice(e)))}if(o.has(i))return;o.add(i),n.add(i),r.push(i);const a=e.get(i);if(a){const t=a.parentId;null!==t&&e.has(t)&&i!==t&&s(t)}n.delete(i),r.pop()}e.forEach((e,t)=>{o.has(t)||s(t)})}(y);for(const[e,t]of y)t.parentId===e&&(m.cyclesDetected++,h(t.original,[e]),y.delete(e))}for(const[e,t]of y){if(t.isGhost)continue;const{parentId:e}=t;if(null==e||e===i)I.push(t.formatted),t.depth=1,m.rootNodes++;else{const o=y.get(e);if(o)o.children.push(t),t.formatted.__parentId=e;else if(a){const o=y.get(e);if(o)o.children.push(t),t.formatted.__parentId=e,t.depth=o.depth+1;else{const o={[n]:e,[s]:[t.formatted],__isGhost:!0,__parentId:null},r={original:{[n]:e},formatted:o,parentId:null,children:[t],depth:1,isGhost:!0};y.set(e,r),I.push(o),t.formatted.__parentId=e,t.depth=2,m.ghostNodesCreated++,m.rootNodes++}}else I.push(t.formatted),t.depth=1,m.rootNodes++}}const N=[];for(I.forEach(e=>{const t=e[n],o=y.get(t);o&&N.push({nodeInfo:o,formattedNode:e,depth:1,path:[t]})});N.length>0;){const{nodeInfo:e,formattedNode:t,depth:r,path:i}=N.pop();if(m.maxDepth=Math.max(m.maxDepth,r),r>c){console.warn(`节点 "${i.join(" -> ")}" 深度超过限制: ${r}`);continue}const a=e.children;if(f&&a.length>0)try{a.sort((e,t)=>f(e.original,t.original))}catch(e){console.warn("子节点排序失败:",e)}const d=[];for(const c of a){const a=c.original[n],l=[...i,a],h=r+1;c.depth=h;let f=c.formatted;const u={level:h,path:l,isLeaf:0===c.children.length,parent:t,childCount:c.children.length};o?f={...o(c.original,u),[s]:[]}:p&&(f={...p(c.original,u),[s]:[]}),f.__parentId=e.original[n],d.push(f),c.formatted=f,N.push({nodeInfo:c,formattedNode:f,depth:h,path:l})}t[s]=d;const l={level:r,path:i,isLeaf:0===d.length,childCount:d.length};o?(Object.assign(t,o(e.original,l)),t[s]=d):p&&(Object.assign(t,p(e.original,l)),t[s]=d)}if(f&&I.length>1)try{I.sort((e,t)=>{const o=e[n],r=t[n],s=y.get(o),i=y.get(r);return s&&i?f(s.original,i.original):0})}catch(e){console.warn("根节点排序失败:",e)}const w=performance.now(),K=process.memoryUsage?.()?.heapUsed||0;return m.buildTime=w-u,m.memoryUsed=(K-g)/1048576,I.length>0&&(I.__stats=m),I},exports.buildMinimalTree=function(e,t={}){const o={idKey:"id",parentKey:"parentId",childrenKey:"children",rootParentId:0,enableGhostNodes:!1,validateNodes:!0,maxDepth:1e3,enableCache:!1,...t};if(!Array.isArray(e)||0===e.length)return[];const n=new Map,r=[];for(const t of e){const e=t[o.idKey];o.validateNodes&&null==e?console.warn(`节点缺少ID字段 "${o.idKey}"，将被忽略:`,t):(n.has(e)&&console.warn(`发现重复ID "${e}"，后一个节点将覆盖前一个`),n.set(e,{...t,[o.childrenKey]:[]}))}const s=new Set;for(const t of e){const e=t[o.idKey],i=t[o.parentKey],a=n.get(e);if(!a)continue;if(s.has(e))continue;s.add(e);if(null==i||i===o.rootParentId)r.push(a);else{const t=n.get(i);if(t)t[o.childrenKey].push(a);else if(o.enableGhostNodes){const e={[o.idKey]:i,[o.childrenKey]:[a],__isGhost:!0};n.set(i,e),r.push(e)}else console.warn(`父节点 "${i}" 不存在，节点 "${e}" 将被作为根节点`),r.push(a)}}return r},exports.validateMinimalTree=function(e,t={}){const o=new Set,n=t.childrenKey||"children";function r(e,s){const i=e[t.idKey||"id"];if(o.has(i))return console.error(`发现循环引用，节点ID: ${i}`),!1;if(o.add(i),s>(t.maxDepth||1e3))return console.error(`树深度超过限制: ${s}`),!1;const a=e[n];if(Array.isArray(a))for(const e of a)if(!r(e,s+1))return!1;return o.delete(i),!0}try{for(const t of e)if(!r(t,1))return!1;return!0}catch(e){return console.error("树验证失败:",e),!1}};
//# sourceMappingURL=index.js.map
