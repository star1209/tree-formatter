"use strict";exports.buildEnhancedTree=function(e,t={},o){const n=t.idKey||"id",r=t.parentKey||"parentId",s=t.childrenKey||"children",a=t.rootParentId??0,i=t.enableGhostNodes||!1,c=!1!==t.validateNodes,d=t.maxDepth||1e3,l=t.detectCycles||!1,h=t.onCycleDetected||((e,t)=>{console.warn(`发现循环引用，路径: ${t.join(" -> ")}`)}),f=t.sortChildren,p=t.formatNode;t.isRootNode;const u=performance.now(),g=process.memoryUsage?.()?.heapUsed||0,m={totalNodes:0,rootNodes:0,maxDepth:0,buildTime:0,memoryUsed:0,cyclesDetected:0,ghostNodesCreated:0};if(!Array.isArray(e)||0===e.length)return[];const y=new Map,I=[];for(const t of e){const e=t[n],a=t[r]??null;if(c&&null==e){console.warn(`节点缺少ID字段 "${n}"，将被忽略:`,t);continue}if(e===a){l&&(h(t,[e]),m.cyclesDetected++);continue}const i={level:0,path:[e],isLeaf:!0,childCount:0};let d;o?(d=o(t,i),d[s]=[]):p?(d=p(t,i),d[s]=[]):d={...t,[s]:[]},y.set(e,{original:t,formatted:d,parentId:a,children:[],depth:0})}if(m.totalNodes=y.size,l&&y.size>0){const e=function(e){const t=new Map,o=new Map;e.forEach((e,n)=>{t.set(n,new Set),o.set(n,0)}),e.forEach((n,r)=>{const s=n.parentId;null!==s&&e.has(s)&&r!==s&&(t.get(s).add(r),o.set(r,(o.get(r)||0)+1))});const n=[],r=[];o.forEach((e,t)=>{0===e&&n.push(t)});for(;n.length>0;){const e=n.shift(),r=t.get(e);r&&r.forEach(e=>{const t=(o.get(e)||1)-1;o.set(e,t),0===t&&n.push(e)})}const s=new Set;return o.forEach((e,n)=>{if(e>0&&!s.has(n)){const e=[];let a=n;for(;!s.has(a);){s.add(a),e.push(a);const n=Array.from(t.get(a)||[]);for(const e of n)if(o.get(e)>0&&!s.has(e)){a=e;break}}e.length>0&&r.push(e)}}),r}(y);e.forEach(e=>{m.cyclesDetected++;const t=y.get(e[0]);t&&(h(t.original,e),y.delete(e[0]))})}for(const[e,t]of y){if(t.isGhost)continue;const{parentId:e}=t;if(null==e||e===a)I.push(t.formatted),t.depth=1,m.rootNodes++;else{const o=y.get(e);if(o)o.children.push(t),t.formatted.__parentId=e;else if(i){const o=y.get(e);if(o)o.children.push(t),t.formatted.__parentId=e,t.depth=o.depth+1;else{const o={[n]:e,[s]:[t.formatted],__isGhost:!0,__parentId:null},r={original:{[n]:e},formatted:o,parentId:null,children:[t],depth:1,isGhost:!0};y.set(e,r),I.push(o),t.formatted.__parentId=e,t.depth=2,m.ghostNodesCreated++,m.rootNodes++}}else I.push(t.formatted),t.depth=1,m.rootNodes++}}const N=[];for(I.forEach(e=>{const t=e[n],o=y.get(t);o&&N.push({nodeInfo:o,formattedNode:e,depth:1,path:[t]})});N.length>0;){const{nodeInfo:e,formattedNode:t,depth:r,path:a}=N.pop();if(m.maxDepth=Math.max(m.maxDepth,r),r>d){console.warn(`节点 "${a.join(" -> ")}" 深度超过限制: ${r}`);continue}const i=e.children;if(f&&i.length>0)try{i.sort((e,t)=>f(e.original,t.original))}catch(e){console.warn("子节点排序失败:",e)}const c=[];for(const d of i){const i=d.original[n],l=[...a,i],h=r+1;d.depth=h;let f=d.formatted;const u={level:h,path:l,isLeaf:0===d.children.length,parent:t,childCount:d.children.length};o?f={...o(d.original,u),[s]:[]}:p&&(f={...p(d.original,u),[s]:[]}),f.__parentId=e.original[n],c.push(f),d.formatted=f,N.push({nodeInfo:d,formattedNode:f,depth:h,path:l})}t[s]=c;const l={level:r,path:a,isLeaf:0===c.length,childCount:c.length};o?(Object.assign(t,o(e.original,l)),t[s]=c):p&&(Object.assign(t,p(e.original,l)),t[s]=c)}if(f&&I.length>1)try{I.sort((e,t)=>{const o=e[n],r=t[n],s=y.get(o),a=y.get(r);return s&&a?f(s.original,a.original):0})}catch(e){console.warn("根节点排序失败:",e)}const w=performance.now(),K=process.memoryUsage?.()?.heapUsed||0;return m.buildTime=w-u,m.memoryUsed=(K-g)/1048576,I.length>0&&(I.__stats=m),I},exports.buildMinimalTree=function(e,t={}){const o={idKey:"id",parentKey:"parentId",childrenKey:"children",rootParentId:0,enableGhostNodes:!1,validateNodes:!0,maxDepth:1e3,enableCache:!1,...t};if(!Array.isArray(e)||0===e.length)return[];const n=new Map,r=[];for(const t of e){const e=t[o.idKey];o.validateNodes&&null==e?console.warn(`节点缺少ID字段 "${o.idKey}"，将被忽略:`,t):(n.has(e)&&console.warn(`发现重复ID "${e}"，后一个节点将覆盖前一个`),n.set(e,{...t,[o.childrenKey]:[]}))}const s=new Set;for(const t of e){const e=t[o.idKey],a=t[o.parentKey],i=n.get(e);if(!i)continue;if(s.has(e))continue;s.add(e);if(null==a||a===o.rootParentId)r.push(i);else{const t=n.get(a);if(t)t[o.childrenKey].push(i);else if(o.enableGhostNodes){const e={[o.idKey]:a,[o.childrenKey]:[i],__isGhost:!0};n.set(a,e),r.push(e)}else console.warn(`父节点 "${a}" 不存在，节点 "${e}" 将被作为根节点`),r.push(i)}}return r},exports.validateMinimalTree=function(e,t={}){const o=new Set,n=t.childrenKey||"children";function r(e,s){const a=e[t.idKey||"id"];if(o.has(a))return console.error(`发现循环引用，节点ID: ${a}`),!1;if(o.add(a),s>(t.maxDepth||1e3))return console.error(`树深度超过限制: ${s}`),!1;const i=e[n];if(Array.isArray(i))for(const e of i)if(!r(e,s+1))return!1;return o.delete(a),!0}try{for(const t of e)if(!r(t,1))return!1;return!0}catch(e){return console.error("树验证失败:",e),!1}};
//# sourceMappingURL=index.js.map
